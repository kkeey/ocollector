#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Exporter.pm"} = <<'EXPORTER';
  package Exporter;
  
  require 5.006;
  
  # Be lean.
  #use strict;
  #no strict 'refs';
  
  our $Debug = 0;
  our $ExportLevel = 0;
  our $Verbose ||= 0;
  our $VERSION = '5.63';
  our (%Cache);
  
  # Carp 1.05+ does this now for us, but we may be running with an old Carp
  $Carp::Internal{Exporter}++;
  
  sub as_heavy {
    require Exporter::Heavy;
    # Unfortunately, this does not work if the caller is aliased as *name = \&foo
    # Thus the need to create a lot of identical subroutines
    my $c = (caller(1))[3];
    $c =~ s/.*:://;
    \&{"Exporter::Heavy::heavy_$c"};
  }
  
  sub export {
    goto &{as_heavy()};
  }
  
  sub import {
    my $pkg = shift;
    my $callpkg = caller($ExportLevel);
  
    if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
      *{$callpkg."::import"} = \&import;
      return;
    }
  
    # We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
    my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    return export $pkg, $callpkg, @_
      if $Verbose or $Debug or @$fail > 1;
    my $export_cache = ($Cache{$pkg} ||= {});
    my $args = @_ or @_ = @$exports;
  
    local $_;
    if ($args and not %$export_cache) {
      s/^&//, $export_cache->{$_} = 1
        foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    }
    my $heavy;
    # Try very hard not to use {} and hence have to  enter scope on the foreach
    # We bomb out of the loop with last as soon as heavy is set.
    if ($args or $fail) {
      ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
                 or @$fail and $_ eq $fail->[0])) and last
                   foreach (@_);
    } else {
      ($heavy = /\W/) and last
        foreach (@_);
    }
    return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    local $SIG{__WARN__} = 
  	sub {require Carp; &Carp::carp};
    # shortcut for the common case of no type character
    *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  }
  
  # Default methods
  
  sub export_fail {
      my $self = shift;
      @_;
  }
  
  # Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
  # *name = \&foo.  Thus the need to create a lot of identical subroutines
  # Otherwise we could have aliased them to export().
  
  sub export_to_level {
    goto &{as_heavy()};
  }
  
  sub export_tags {
    goto &{as_heavy()};
  }
  
  sub export_ok_tags {
    goto &{as_heavy()};
  }
  
  sub require_version {
    goto &{as_heavy()};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Exporter - Implements default import method for modules
  
  =head1 SYNOPSIS
  
  In module F<YourModule.pm>:
  
    package YourModule;
    require Exporter;
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  or
  
    package YourModule;
    use Exporter 'import'; # gives you Exporter's import() method directly
    @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  In other files which wish to use C<YourModule>:
  
    use YourModule qw(frobnicate);      # import listed symbols
    frobnicate ($left, $right)          # calls YourModule::frobnicate
  
  Take a look at L</Good Practices> for some variants
  you will like to use in modern Perl code.
  
  =head1 DESCRIPTION
  
  The Exporter module implements an C<import> method which allows a module
  to export functions and variables to its users' namespaces. Many modules
  use Exporter rather than implementing their own C<import> method because
  Exporter provides a highly flexible interface, with an implementation optimised
  for the common case.
  
  Perl automatically calls the C<import> method when processing a
  C<use> statement for a module. Modules and C<use> are documented
  in L<perlfunc> and L<perlmod>. Understanding the concept of
  modules and how the C<use> statement operates is important to
  understanding the Exporter.
  
  =head2 How to Export
  
  The arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of
  symbols that are going to be exported into the users name space by
  default, or which they can request to be exported, respectively.  The
  symbols can represent functions, scalars, arrays, hashes, or typeglobs.
  The symbols must be given by full name with the exception that the
  ampersand in front of a function is optional, e.g.
  
      @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
      @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
  
  If you are only exporting function names it is recommended to omit the
  ampersand, as the implementation is faster this way.
  
  =head2 Selecting What To Export
  
  Do B<not> export method names!
  
  Do B<not> export anything else by default without a good reason!
  
  Exports pollute the namespace of the module user.  If you must export
  try to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or
  common symbol names to reduce the risk of name clashes.
  
  Generally anything not exported is still accessible from outside the
  module using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)
  syntax.  By convention you can use a leading underscore on names to
  informally indicate that they are 'internal' and not for public use.
  
  (It is actually possible to get private functions by saying:
  
    my $subref = sub { ... };
    $subref->(@args);            # Call it as a function
    $obj->$subref(@args);        # Use it as a method
  
  However if you use them for methods it is up to you to figure out
  how to make inheritance work.)
  
  As a general rule, if the module is trying to be object oriented
  then export nothing. If it's just a collection of functions then
  C<@EXPORT_OK> anything but use C<@EXPORT> with caution. For function and
  method names use barewords in preference to names prefixed with
  ampersands for the export lists.
  
  Other module design guidelines can be found in L<perlmod>.
  
  =head2 How to Import
  
  In other files which wish to use your module there are three basic ways for
  them to load your module and import its symbols:
  
  =over 4
  
  =item C<use YourModule;>
  
  This imports all the symbols from YourModule's C<@EXPORT> into the namespace
  of the C<use> statement.
  
  =item C<use YourModule ();>
  
  This causes perl to load your module but does not import any symbols.
  
  =item C<use YourModule qw(...);>
  
  This imports only the symbols listed by the caller into their namespace.
  All listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error
  occurs. The advanced export features of Exporter are accessed like this,
  but with list entries that are syntactically distinct from symbol names.
  
  =back
  
  Unless you want to use its advanced features, this is probably all you
  need to know to use Exporter.
  
  =head1 Advanced features
  
  =head2 Specialised Import Lists
  
  If any of the entries in an import list begins with !, : or / then
  the list is treated as a series of specifications which either add to
  or delete from the list of names to import. They are processed left to
  right. Specifications are in the form:
  
      [!]name         This name only
      [!]:DEFAULT     All names in @EXPORT
      [!]:tag         All names in $EXPORT_TAGS{tag} anonymous list
      [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
  
  A leading ! indicates that matching names should be deleted from the
  list of names to import.  If the first specification is a deletion it
  is treated as though preceded by :DEFAULT. If you just want to import
  extra names in addition to the default set you will still need to
  include :DEFAULT explicitly.
  
  e.g., F<Module.pm> defines:
  
      @EXPORT      = qw(A1 A2 A3 A4 A5);
      @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
      %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
  
      Note that you cannot use tags in @EXPORT or @EXPORT_OK.
      Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.
  
  An application using Module can say something like:
  
      use Module qw(:DEFAULT :T2 !B3 A3);
  
  Other examples include:
  
      use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
      use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
  
  Remember that most patterns (using //) will need to be anchored
  with a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.
  
  You can say C<BEGIN { $Exporter::Verbose=1 }> to see how the
  specifications are being processed and what is actually being imported
  into modules.
  
  =head2 Exporting without using Exporter's import method
  
  Exporter has a special method, 'export_to_level' which is used in situations
  where you can't directly call Exporter's import method. The export_to_level
  method looks like:
  
      MyPackage->export_to_level($where_to_export, $package, @what_to_export);
  
  where C<$where_to_export> is an integer telling how far up the calling stack
  to export your symbols, and C<@what_to_export> is an array telling what
  symbols *to* export (usually this is C<@_>).  The C<$package> argument is
  currently unused.
  
  For example, suppose that you have a module, A, which already has an
  import function:
  
      package A;
  
      @ISA = qw(Exporter);
      @EXPORT_OK = qw ($b);
  
      sub import
      {
  	$A::b = 1;     # not a very useful import method
      }
  
  and you want to Export symbol C<$A::b> back to the module that called 
  package A. Since Exporter relies on the import method to work, via 
  inheritance, as it stands Exporter::import() will never get called. 
  Instead, say the following:
  
      package A;
      @ISA = qw(Exporter);
      @EXPORT_OK = qw ($b);
  
      sub import
      {
  	$A::b = 1;
  	A->export_to_level(1, @_);
      }
  
  This will export the symbols one level 'above' the current package - ie: to 
  the program or module that used package A. 
  
  Note: Be careful not to modify C<@_> at all before you call export_to_level
  - or people using your package will get very unexplained results!
  
  =head2 Exporting without inheriting from Exporter
  
  By including Exporter in your C<@ISA> you inherit an Exporter's import() method
  but you also inherit several other helper methods which you probably don't
  want. To avoid this you can do
  
    package YourModule;
    use Exporter qw( import );
  
  which will export Exporter's own import() method into YourModule.
  Everything will work as before but you won't need to include Exporter in
  C<@YourModule::ISA>.
  
  Note: This feature was introduced in version 5.57
  of Exporter, released with perl 5.8.3.
  
  =head2 Module Version Checking
  
  The Exporter module will convert an attempt to import a number from a
  module into a call to C<< $module_name->require_version($value) >>. This can
  be used to validate that the version of the module being used is
  greater than or equal to the required version.
  
  The Exporter module supplies a default C<require_version> method which
  checks the value of C<$VERSION> in the exporting module.
  
  Since the default C<require_version> method treats the C<$VERSION> number as
  a simple numeric value it will regard version 1.10 as lower than
  1.9. For this reason it is strongly recommended that you use numbers
  with at least two decimal places, e.g., 1.09.
  
  =head2 Managing Unknown Symbols
  
  In some situations you may want to prevent certain symbols from being
  exported. Typically this applies to extensions which have functions
  or constants that may not exist on some systems.
  
  The names of any symbols that cannot be exported should be listed
  in the C<@EXPORT_FAIL> array.
  
  If a module attempts to import any of these symbols the Exporter
  will give the module an opportunity to handle the situation before
  generating an error. The Exporter will call an export_fail method
  with a list of the failed symbols:
  
    @failed_symbols = $module_name->export_fail(@failed_symbols);
  
  If the C<export_fail> method returns an empty list then no error is
  recorded and all the requested symbols are exported. If the returned
  list is not empty then an error is generated for each symbol and the
  export fails. The Exporter provides a default C<export_fail> method which
  simply returns the list unchanged.
  
  Uses for the C<export_fail> method include giving better error messages
  for some symbols and performing lazy architectural checks (put more
  symbols into C<@EXPORT_FAIL> by default and then take them out if someone
  actually tries to use them and an expensive check shows that they are
  usable on that platform).
  
  =head2 Tag Handling Utility Functions
  
  Since the symbols listed within C<%EXPORT_TAGS> must also appear in either
  C<@EXPORT> or C<@EXPORT_OK>, two utility functions are provided which allow
  you to easily add tagged sets of symbols to C<@EXPORT> or C<@EXPORT_OK>:
  
    %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
    Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
  
  Any names which are not tags are added to C<@EXPORT> or C<@EXPORT_OK>
  unchanged but will trigger a warning (with C<-w>) to avoid misspelt tags
  names being silently added to C<@EXPORT> or C<@EXPORT_OK>. Future versions
  may make this a fatal error.
  
  =head2 Generating combined tags
  
  If several symbol categories exist in C<%EXPORT_TAGS>, it's usually
  useful to create the utility ":all" to simplify "use" statements.
  
  The simplest way to do this is:
  
    %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    # add all the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
    }
  
  F<CGI.pm> creates an ":all" tag which contains some (but not really
  all) of its categories.  That could be done with one small
  change:
  
    # add some of the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
          foreach qw/html2 html3 netscape form cgi internal/;
    }
  
  Note that the tag names in C<%EXPORT_TAGS> don't have the leading ':'.
  
  =head2 C<AUTOLOAD>ed Constants
  
  Many modules make use of C<AUTOLOAD>ing for constant subroutines to
  avoid having to compile and waste memory on rarely used values (see
  L<perlsub> for details on constant subroutines).  Calls to such
  constant subroutines are not optimized away at compile time because
  they can't be checked at compile time for constancy.
  
  Even if a prototype is available at compile time, the body of the
  subroutine is not (it hasn't been C<AUTOLOAD>ed yet). perl needs to
  examine both the C<()> prototype and the body of a subroutine at
  compile time to detect that it can safely replace calls to that
  subroutine with the constant value.
  
  A workaround for this is to call the constants once in a C<BEGIN> block:
  
     package My ;
  
     use Socket ;
  
     foo( SO_LINGER );     ## SO_LINGER NOT optimized away; called at runtime
     BEGIN { SO_LINGER }
     foo( SO_LINGER );     ## SO_LINGER optimized away at compile time.
  
  This forces the C<AUTOLOAD> for C<SO_LINGER> to take place before
  SO_LINGER is encountered later in C<My> package.
  
  If you are writing a package that C<AUTOLOAD>s, consider forcing
  an C<AUTOLOAD> for any constants explicitly imported by other packages
  or which are usually used when your package is C<use>d.
  
  =head1 Good Practices
  
  =head2 Declaring C<@EXPORT_OK> and Friends
  
  When using C<Exporter> with the standard C<strict> and C<warnings>
  pragmas, the C<our> keyword is needed to declare the package
  variables C<@EXPORT_OK>, C<@EXPORT>, C<@ISA>, etc.
  
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw(munge frobnicate);
  
  If backward compatibility for Perls under 5.6 is important,
  one must write instead a C<use vars> statement.
  
    use vars qw(@ISA @EXPORT_OK);
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);
  
  =head2 Playing Safe
  
  There are some caveats with the use of runtime statements
  like C<require Exporter> and the assignment to package
  variables, which can very subtle for the unaware programmer.
  This may happen for instance with mutually recursive
  modules, which are affected by the time the relevant
  constructions are executed.
  
  The ideal (but a bit ugly) way to never have to think
  about that is to use C<BEGIN> blocks. So the first part
  of the L</SYNOPSIS> code could be rewritten as:
  
    package YourModule;
  
    use strict;
    use warnings;
  
    our (@ISA, @EXPORT_OK);
    BEGIN {
       require Exporter;
       @ISA = qw(Exporter);
       @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    }
  
  The C<BEGIN> will assure that the loading of F<Exporter.pm>
  and the assignments to C<@ISA> and C<@EXPORT_OK> happen
  immediately, leaving no room for something to get awry
  or just plain wrong.
  
  With respect to loading C<Exporter> and inheriting, there
  are alternatives with the use of modules like C<base> and C<parent>.
  
    use base qw( Exporter );
    # or
    use parent qw( Exporter );
  
  Any of these statements are nice replacements for
  C<BEGIN { require Exporter; @ISA = qw(Exporter); }>
  with the same compile-time effect. The basic difference
  is that C<base> code interacts with declared C<fields>
  while C<parent> is a streamlined version of the older
  C<base> code to just establish the IS-A relationship.
  
  For more details, see the documentation and code of
  L<base> and L<parent>.
  
  Another thorough remedy to that runtime vs. 
  compile-time trap is to use L<Exporter::Easy>,
  which is a wrapper of Exporter that allows all
  boilerplate code at a single gulp in the
  use statement.
  
     use Exporter::Easy (
         OK => [ qw(munge frobnicate) ],
     );
     # @ISA setup is automatic
     # all assignments happen at compile time
  
  =head2 What not to Export
  
  You have been warned already in L</Selecting What To Export>
  to not export:
  
  =over 4
  
  =item *
  
  method names (because you don't need to
  and that's likely to not do what you want),
  
  =item *
  
  anything by default (because you don't want to surprise your users...
  badly)
  
  =item *
  
  anything you don't need to (because less is more)
  
  =back
  
  There's one more item to add to this list. Do B<not>
  export variable names. Just because C<Exporter> lets you
  do that, it does not mean you should.
  
    @EXPORT_OK = qw( $svar @avar %hvar ); # DON'T!
  
  Exporting variables is not a good idea. They can
  change under the hood, provoking horrible
  effects at-a-distance, that are too hard to track
  and to fix. Trust me: they are not worth it.
  
  To provide the capability to set/get class-wide
  settings, it is best instead to provide accessors
  as subroutines or class methods instead.
  
  =head1 SEE ALSO
  
  C<Exporter> is definitely not the only module with
  symbol exporter capabilities. At CPAN, you may find
  a bunch of them. Some are lighter. Some
  provide improved APIs and features. Peek the one
  that fits your needs. The following is
  a sample list of such modules.
  
      Exporter::Easy
      Exporter::Lite
      Exporter::Renaming
      Exporter::Tidy
      Sub::Exporter / Sub::Installer
      Perl6::Export / Perl6::Export::Attrs
  
  =head1 LICENSE
  
  This library is free software. You can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =cut
  
  
  
EXPORTER

$fatpacked{"Exporter/Heavy.pm"} = <<'EXPORTER_HEAVY';
  package Exporter::Heavy;
  
  use strict;
  no strict 'refs';
  
  # On one line so MakeMaker will see it.
  require Exporter;  our $VERSION = $Exporter::VERSION;
  
  # Carp 1.05+ does this now for us, but we may be running with an old Carp
  $Carp::Internal{'Exporter::Heavy'}++;
  
  =head1 NAME
  
  Exporter::Heavy - Exporter guts
  
  =head1 SYNOPSIS
  
  (internal use only)
  
  =head1 DESCRIPTION
  
  No user-serviceable parts inside.
  
  =cut
  
  #
  # We go to a lot of trouble not to 'require Carp' at file scope,
  #  because Carp requires Exporter, and something has to give.
  #
  
  sub _rebuild_cache {
      my ($pkg, $exports, $cache) = @_;
      s/^&// foreach @$exports;
      @{$cache}{@$exports} = (1) x @$exports;
      my $ok = \@{"${pkg}::EXPORT_OK"};
      if (@$ok) {
  	s/^&// foreach @$ok;
  	@{$cache}{@$ok} = (1) x @$ok;
      }
  }
  
  sub heavy_export {
  
      # First make import warnings look like they're coming from the "use".
      local $SIG{__WARN__} = sub {
  	my $text = shift;
  	if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//) {
  	    require Carp;
  	    local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	    Carp::carp($text);
  	}
  	else {
  	    warn $text;
  	}
      };
      local $SIG{__DIE__} = sub {
  	require Carp;
  	local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")
  	    if $_[0] =~ /^Unable to create sub named "(.*?)::"/;
      };
  
      my($pkg, $callpkg, @imports) = @_;
      my($type, $sym, $cache_is_current, $oops);
      my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
                                     $Exporter::Cache{$pkg} ||= {});
  
      if (@imports) {
  	if (!%$export_cache) {
  	    _rebuild_cache ($pkg, $exports, $export_cache);
  	    $cache_is_current = 1;
  	}
  
  	if (grep m{^[/!:]}, @imports) {
  	    my $tagsref = \%{"${pkg}::EXPORT_TAGS"};
  	    my $tagdata;
  	    my %imports;
  	    my($remove, $spec, @names, @allexports);
  	    # negated first item implies starting with default set:
  	    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;
  	    foreach $spec (@imports){
  		$remove = $spec =~ s/^!//;
  
  		if ($spec =~ s/^://){
  		    if ($spec eq 'DEFAULT'){
  			@names = @$exports;
  		    }
  		    elsif ($tagdata = $tagsref->{$spec}) {
  			@names = @$tagdata;
  		    }
  		    else {
  			warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];
  			++$oops;
  			next;
  		    }
  		}
  		elsif ($spec =~ m:^/(.*)/$:){
  		    my $patn = $1;
  		    @allexports = keys %$export_cache unless @allexports; # only do keys once
  		    @names = grep(/$patn/, @allexports); # not anchored by default
  		}
  		else {
  		    @names = ($spec); # is a normal symbol name
  		}
  
  		warn "Import ".($remove ? "del":"add").": @names "
  		    if $Exporter::Verbose;
  
  		if ($remove) {
  		   foreach $sym (@names) { delete $imports{$sym} } 
  		}
  		else {
  		    @imports{@names} = (1) x @names;
  		}
  	    }
  	    @imports = keys %imports;
  	}
  
          my @carp;
  	foreach $sym (@imports) {
  	    if (!$export_cache->{$sym}) {
  		if ($sym =~ m/^\d/) {
  		    $pkg->VERSION($sym); # inherit from UNIVERSAL
  		    # If the version number was the only thing specified
  		    # then we should act as if nothing was specified:
  		    if (@imports == 1) {
  			@imports = @$exports;
  			last;
  		    }
  		    # We need a way to emulate 'use Foo ()' but still
  		    # allow an easy version check: "use Foo 1.23, ''";
  		    if (@imports == 2 and !$imports[1]) {
  			@imports = ();
  			last;
  		    }
  		} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {
  		    # Last chance - see if they've updated EXPORT_OK since we
  		    # cached it.
  
  		    unless ($cache_is_current) {
  			%$export_cache = ();
  			_rebuild_cache ($pkg, $exports, $export_cache);
  			$cache_is_current = 1;
  		    }
  
  		    if (!$export_cache->{$sym}) {
  			# accumulate the non-exports
  			push @carp,
  			  qq["$sym" is not exported by the $pkg module\n];
  			$oops++;
  		    }
  		}
  	    }
  	}
  	if ($oops) {
  	    require Carp;
  	    Carp::croak("@{carp}Can't continue after import errors");
  	}
      }
      else {
  	@imports = @$exports;
      }
  
      my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
                                $Exporter::FailCache{$pkg} ||= {});
  
      if (@$fail) {
  	if (!%$fail_cache) {
  	    # Build cache of symbols. Optimise the lookup by adding
  	    # barewords twice... both with and without a leading &.
  	    # (Technique could be applied to $export_cache at cost of memory)
  	    my @expanded = map { /^\w/ ? ($_, '&'.$_) : $_ } @$fail;
  	    warn "${pkg}::EXPORT_FAIL cached: @expanded" if $Exporter::Verbose;
  	    @{$fail_cache}{@expanded} = (1) x @expanded;
  	}
  	my @failed;
  	foreach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }
  	if (@failed) {
  	    @failed = $pkg->export_fail(@failed);
  	    foreach $sym (@failed) {
                  require Carp;
  		Carp::carp(qq["$sym" is not implemented by the $pkg module ],
  			"on this architecture");
  	    }
  	    if (@failed) {
  		require Carp;
  		Carp::croak("Can't continue after import errors");
  	    }
  	}
      }
  
      warn "Importing into $callpkg from $pkg: ",
  		join(", ",sort @imports) if $Exporter::Verbose;
  
      foreach $sym (@imports) {
  	# shortcut for the common case of no type character
  	(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
  	    unless $sym =~ s/^(\W)//;
  	$type = $1;
  	no warnings 'once';
  	*{"${callpkg}::$sym"} =
  	    $type eq '&' ? \&{"${pkg}::$sym"} :
  	    $type eq '$' ? \${"${pkg}::$sym"} :
  	    $type eq '@' ? \@{"${pkg}::$sym"} :
  	    $type eq '%' ? \%{"${pkg}::$sym"} :
  	    $type eq '*' ?  *{"${pkg}::$sym"} :
  	    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
      }
  }
  
  sub heavy_export_to_level
  {
        my $pkg = shift;
        my $level = shift;
        (undef) = shift;			# XXX redundant arg
        my $callpkg = caller($level);
        $pkg->export($callpkg, @_);
  }
  
  # Utility functions
  
  sub _push_tags {
      my($pkg, $var, $syms) = @_;
      my @nontag = ();
      my $export_tags = \%{"${pkg}::EXPORT_TAGS"};
      push(@{"${pkg}::$var"},
  	map { $export_tags->{$_} ? @{$export_tags->{$_}} 
                                   : scalar(push(@nontag,$_),$_) }
  		(@$syms) ? @$syms : keys %$export_tags);
      if (@nontag and $^W) {
  	# This may change to a die one day
  	require Carp;
  	Carp::carp(join(", ", @nontag)." are not tags of $pkg");
      }
  }
  
  sub heavy_require_version {
      my($self, $wanted) = @_;
      my $pkg = ref $self || $self;
      return ${pkg}->VERSION($wanted);
  }
  
  sub heavy_export_tags {
    _push_tags((caller)[0], "EXPORT",    \@_);
  }
  
  sub heavy_export_ok_tags {
    _push_tags((caller)[0], "EXPORT_OK", \@_);
  }
  
  1;
EXPORTER_HEAVY

$fatpacked{"File/ReadBackwards.pm"} = <<'FILE_READBACKWARDS';
  # File::ReadBackwards.pm
  
  # Copyright (C) 2003 by Uri Guttman. All rights reserved.
  # mail bugs, comments and feedback to uri@stemsystems.com
  
  package File::ReadBackwards ;
  
  use strict ;
  
  use vars qw( $VERSION ) ;
  
  $VERSION = '1.04' ;
  
  use Symbol ;
  use Fcntl qw( :seek O_RDONLY ) ;
  use Carp ;
  
  my $max_read_size = 1 << 13 ;
  
  my $default_rec_sep ;
  
  BEGIN {
  
  # set the default record separator according to this OS
  # this needs testing and expansion.
  
  # look for CR/LF types
  # then look for CR types
  # else it's a LF type
  
  	if ( $^O =~ /win32/i || $^O =~ /vms/i ) {
  
  		$default_rec_sep = "\015\012" ;
  	}
  	elsif ( $^O =~ /mac/i ) {
  
  		$default_rec_sep = "\015" ;
  	}
  	else {
  		$default_rec_sep = "\012" ;
  	}
  
  # the tied interface is exactly the same as the object one, so all we
  # need to do is to alias the subs with typeglobs
  
  	*TIEHANDLE = \&new ;
  	*READLINE = \&readline ;
   	*EOF = \&eof ;
   	*CLOSE = \&close ;
   	*TELL = \&tell ;
  
  # added getline alias for compatibility with IO::Handle
  
  	*getline = \&readline ;
  }
  
  
  # constructor for File::ReadBackwards
  
  sub new {
  
  	my( $class, $filename, $rec_sep, $sep_is_regex ) = @_ ;
  
  # check that we have a filename
  
  	defined( $filename ) || return ;
  
  # see if this file uses the default of a cr/lf separator
  # those files will get cr/lf converted to \n
  
  	$rec_sep ||= $default_rec_sep ;
  	my $is_crlf = $rec_sep eq "\015\012" ;
  
  # get a handle and open the file
  
  	my $handle = gensym ;
  	sysopen( $handle, $filename, O_RDONLY ) || return ;
  	binmode $handle ;
  
  # seek to the end of the file and get its size
  
  	my $seek_pos = sysseek( $handle, 0, SEEK_END ) or return ;
  
  # get the size of the first block to read,
  # either a trailing partial one (the % size) or full sized one (max read size)
  
  	my $read_size = $seek_pos % $max_read_size || $max_read_size ;
  
  # create the object
  
  	my $self = bless {
  			'file_name'	=> $filename,
  			'handle'	=> $handle,
  			'read_size'	=> $read_size,
  			'seek_pos'	=> $seek_pos,
  			'lines'		=> [],
  			'is_crlf'	=> $is_crlf,
  			'rec_sep'	=> $rec_sep,
  			'sep_is_regex'	=> $sep_is_regex,
  
  		}, $class ;
  
  	return( $self ) ;
  }
  
  # read the previous record from the file
  # 
  sub readline {
  
  	my( $self, $line_ref ) = @_ ;
  
  	my $read_buf ;
  
  # get the buffer of lines
  
  	my $lines_ref = $self->{'lines'} ;
  
  	return unless $lines_ref ;
  
  	while( 1 ) {
  
  # see if there is more than 1 line in the buffer
  
  		if ( @{$lines_ref} > 1 ) {
  
  # we have a complete line so return it
  # and convert those damned cr/lf lines to \n
  
  			$lines_ref->[-1] =~ s/\015\012/\n/
  					if $self->{'is_crlf'} ;
  
  			return( pop @{$lines_ref} ) ;
  		}
  
  # we don't have a complete, so have to read blocks until we do
  
  		my $seek_pos = $self->{'seek_pos'} ;
  
  # see if we are at the beginning of the file
  
  		if ( $seek_pos == 0 ) {
  
  # the last read never made more lines, so return the last line in the buffer
  # if no lines left then undef will be returned
  # and convert those damned cr/lf lines to \n
  
  			$lines_ref->[-1] =~ s/\015\012/\n/
  					if @{$lines_ref} && $self->{'is_crlf'} ;
  
  			return( pop @{$lines_ref} ) ;
  		}
  
  # we have to read more text so get the handle and the current read size
  
  		my $handle = $self->{'handle'} ;
  		my $read_size = $self->{'read_size'} ;
  
  # after the first read, always read the maximum size
  
  		$self->{'read_size'} = $max_read_size ;
  
  # seek to the beginning of this block and save the new seek position
  
  		$seek_pos -= $read_size ;
  		sysseek( $handle, $seek_pos, SEEK_SET ) ;
  		$self->{'seek_pos'} = $seek_pos ;
  
  # read in the next (previous) block of text
  
  		my $read_cnt = sysread( $handle, $read_buf, $read_size ) ;
  
  # prepend the read buffer to the leftover (possibly partial) line
  
  		my $text = $read_buf ;
  		$text .= shift @{$lines_ref} if @{$lines_ref} ;
  
  # split the buffer into a list of lines
  # this may want to be $/ but reading files backwards assumes plain text and
  # newline separators
  
  		@{$lines_ref} = ( $self->{'sep_is_regex'} ) ?
  	 		$text =~ /(.*?$self->{'rec_sep'}|.+)/gs :
  			$text =~ /(.*?\Q$self->{'rec_sep'}\E|.+)/gs ;
  
  #print "Lines \n=>", join( "<=\n=>", @{$lines_ref} ), "<=\n" ;
  
  	}
  }
  
  sub eof {
  
  	my ( $self ) = @_ ;
  
  	my $seek_pos = $self->{'seek_pos'} ;
  	my $lines_count = @{ $self->{'lines'} } ;
  	return( $seek_pos == 0 && $lines_count == 0 ) ;
  }
  
  sub tell {
  	my ( $self ) = @_ ;
  
  	my $seek_pos = $self->{'seek_pos'} ;
  	$seek_pos + length(join "", @{ $self->{'lines'} });
  }
  
  sub get_handle {
  	my ( $self ) = @_ ;
  
  	my $handle = $self->{handle} ;
  	seek( $handle, $self->tell, SEEK_SET ) ;
  	return $handle ;
  }
  
  sub close {
  
  	my ( $self ) = @_ ;
  
  	my $handle = delete( $self->{'handle'} ) ;
  	delete( $self->{'lines'} ) ;
  
  	CORE::close( $handle ) ;
  }
  
  __END__
  
  
  =head1 NAME
  
  File::ReadBackwards.pm -- Read a file backwards by lines.
   
  
  =head1 SYNOPSIS
  
      use File::ReadBackwards ;
  
      # Object interface
  
      $bw = File::ReadBackwards->new( 'log_file' ) or
  			die "can't read 'log_file' $!" ;
  
      while( defined( $log_line = $bw->readline ) ) {
  	    print $log_line ;
      }
  
      # ... or the alternative way of reading
  
      until ( $bw->eof ) {
  	    print $bw->readline ;
      }
  
      # Tied Handle Interface
  
      tie *BW, 'File::ReadBackwards', 'log_file' or
  			die "can't read 'log_file' $!" ;
  
      while( <BW> ) {
  	    print ;
      }
  
  =head1 DESCRIPTION
    
  
  This module reads a file backwards line by line. It is simple to use,
  memory efficient and fast. It supports both an object and a tied handle
  interface.
  
  It is intended for processing log and other similar text files which
  typically have their newest entries appended to them. By default files
  are assumed to be plain text and have a line ending appropriate to the
  OS. But you can set the input record separator string on a per file
  basis.
  
  
  =head1 OBJECT INTERFACE
   
  These are the methods in C<File::ReadBackwards>' object interface:
  
  
  =head2 new( $file, [$rec_sep], [$sep_is_regex] )
  
  C<new> takes as arguments a filename, an optional record separator and
  an optional flag that marks the record separator as a regular
  expression. It either returns the object on a successful open or undef
  upon failure. $! is set to the error code if any.
  
  =head2 readline
  
  C<readline> takes no arguments and it returns the previous line in the
  file or undef when there are no more lines in the file. If the file is
  a non-seekable file (e.g. a pipe), then undef is returned.
  
  =head2 getline
  
  C<getline> is an alias for the readline method. It is here for
  compatibilty with the IO::* classes which has a getline method.
  
  =head2 eof
  
  C<eof> takes no arguments and it returns true when readline() has
  iterated through the whole file.
  
  =head2 close
  
  C<close> takes no arguments and it closes the handle
  
  =head2 tell
  
  C<tell> takes no arguments and it returns the current filehandle position.
  This value may be used to seek() back to this position using a normal
  file handle.
  
  =head2 get_handle
  
  C<get_handle> takes no arguments and it returns the internal Perl
  filehandle used by the File::ReadBackwards object.  This handle may be
  used to read the file forward. Its seek position will be set to the
  position that is returned by the tell() method.  Note that
  interleaving forward and reverse reads may produce unpredictable
  results.  The only use supported at present is to read a file backward
  to a certain point, then use 'handle' to extract the handle, and read
  forward from that point.
  
  =head1 TIED HANDLE INTERFACE
  
  =head2 tie( *HANDLE, 'File::ReadBackwards', $file, [$rec_sep], [$sep_is_regex] )
   
  
  The TIEHANDLE, READLINE, EOF, CLOSE and TELL methods are aliased to
  the new, readline, eof, close and tell methods respectively so refer
  to them for their arguments and API.  Once you have tied a handle to
  File::ReadBackwards the only I/O operation permissible is <> which
  will read the previous line. You can call eof() and close() on the
  tied handle as well. All other tied handle operations will generate an
  unknown method error. Do not seek, write or perform any other
  unsupported operations on the tied handle.
  
  =head1 LINE AND RECORD ENDINGS
   
  
  Since this module needs to use low level I/O for efficiency, it can't
  portably seek and do block I/O without managing line ending conversions.
  This module supports the default record separators of normal line ending
  strings used by the OS. You can also set the separator on a per file
  basis.
  
  The record separator is a regular expression by default, which differs
  from the behavior of $/.
  
  Only if the record separator is B<not> specified and it defaults to
  CR/LF (e.g, VMS, redmondware) will it will be converted to a single
  newline. Unix and MacOS files systems use only a single character for
  line endings and the lines are left unchanged.  This means that for
  native text files, you should be able to process their lines backwards
  without any problems with line endings. If you specify a record
  separator, no conversions will be done and you will get the records as
  if you read them in binary mode.
  
  =head1 DESIGN
  
  It works by reading a large (8kb) block of data from the end of the
  file.  It then splits them on the record separator and stores a list of
  records in the object. Each call to readline returns the top record of
  the list and if the list is empty it refills it by reading the previous
  block from the file and splitting it.  When the beginning of the file is
  reached and there are no more lines, undef is returned.  All boundary
  conditions are handled correctly i.e. if there is a trailing partial
  line (no newline) it will be the first line returned and lines larger
  than the read buffer size are handled properly.
  
  
  =head1 NOTES
   
  
  There is no support for list context in either the object or tied
  interfaces. If you want to slurp all of the lines into an array in
  backwards order (and you don't care about memory usage) just do:
  
  	@back_lines = reverse <FH>.
  
  This module is only intended to read one line at a time from the end of
  a file to the beginning.
  
  =head1 AUTHOR
   
  
  Uri Guttman, uri@stemsystems.com
  
  =head1 COPYRIGHT
   
  
  Copyright (C) 2003 by Uri Guttman. All rights reserved.  This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
FILE_READBACKWARDS

$fatpacked{"Getopt/Long.pm"} = <<'GETOPT_LONG';
  # Getopt::Long.pm -- Universal options parsing
  
  package Getopt::Long;
  
  # RCS Status      : $Id: Long.pm,v 2.76 2009/03/30 20:54:30 jv Exp $
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Mon Mar 30 22:51:17 2009
  # Update Count    : 1601
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION        =  2.38;
  # For testing versions only.
  #use vars qw($VERSION_STRING);
  #$VERSION_STRING = "2.38";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptions (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT => "[-+]?[0-9._]+(\.[0-9_]+)?([eE][-+]?[0-9_]+)?";
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consitent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION (",
  	   '$Revision: 2.76 $', ") ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: (@$argv)",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( (defined ($cb = $linkage{'<>'})) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			&$cb
  			  (Getopt::Long::CallBack->new
  			   (name    => $tryopt,
  			    ctl     => $ctl,
  			    opctl   => \%opctl,
  			    linkage => \%linkage,
  			    prefix  => $prefix,
  			   ));
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless $opt =~ /^$prefix(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = $+;
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
            || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	  && $opt =~ /^([^=]+)=(.*)$/s ) {
  	$opt = $1;
  	$optarg = $2;
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( $bundling && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $_;
  		$hit = $opctl->{$hit}->[CTL_CNAME]
  		  if defined $opctl->{$hit}->[CTL_CNAME];
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt) if $ignorecase;
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0) ;#unless $mand;
  	$optarg = 0 unless $type eq 's';
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	# We require at least one digit before a point or 'e',
  	# and at least one digit following the point and 'e'.
  	# [-]NN[.NN][eNN]
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	# We require at least one digit before a point or 'e',
  	# and at least one digit following the point and 'e'.
  	# [-]NN[.NN][eNN]
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown config parameter \"$opt\"")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR;
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    $result = GetOptions ("length=i" => \$length,    # numeric
                          "file=s"   => \$data,      # string
  			"verbose"  => \$verbose);  # flag
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, hence the name Getopt::Long. This module also
  supports single-character options and bundling. Single character
  options may be any alphabetic character, a question mark, and a dash.
  Long options may consist of a series of letters, digits, and dashes.
  Although this is currently not enforced by Getopt::Long, multiple
  consecutive dashes are not allowed, and the option name must not end
  with a dash.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages to
  STDERR, and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a scalar reference as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> (or C<@$libfiles>) would
  contain two strings upon completion: C<"lib/srdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second arguments is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = new Getopt::Long::Parser;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitstatus => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  would set all three.
  
  Getopt::Long supports two levels of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The first level of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  would set C<a>, C<v> and C<x>, but
  
      --vax
  
  would set C<vax>.
  
  The second level of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> would set the option C<vax>.
  
  When any level of bundling is enabled, option values may be inserted
  in the bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  fully compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching long option names. If,
  however, bundling is enabled as well, single character options will be
  treated case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  Options that are unknown, ambiguous or supplied with an invalid option
  value are passed through in C<@ARGV> instead of being flagged as
  errors. This makes it possible to write wrapper scripts that process
  only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at
  the first unrecognized option, or non-option, whichever comes first.
  However, if C<permute> is enabled instead, results can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a progam executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2009 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"Net/Address/IP/Local.pm"} = <<'NET_ADDRESS_IP_LOCAL';
  #
  # Net::Address::IP::Local class,
  # a class for discovering the local system's IP address.
  #
  # (C) 2005-2009 Julian Mehnle <julian@mehnle.net>
  # $Id: Local.pm 24 2009-01-14 21:23:40Z julian $
  #
  ###############################################################################
  
  =head1 NAME
  
  Net::Address::IP::Local - A class for discovering the local system's IP address
  
  =cut
  
  package Net::Address::IP::Local;
  
  =head1 VERSION
  
  0.1.2
  
  =cut
  
  use version; our $VERSION = qv('0.1.2');
  
  use warnings;
  use strict;
  
  use Error ':try';
  
  use constant TRUE   => (0 == 0);
  use constant FALSE  => not TRUE;
  
  use constant remote_address_ipv4_default => '198.41.0.4';           # a.root-servers.net
  use constant remote_address_ipv6_default => '2001:503:ba3e::2:30';  # a.root-servers.net
  
  use constant remote_port_default         => 53;                     # DNS
  
  =head1 SYNOPSIS
  
      use Net::Address::IP::Local;
      
      # Get the local system's IP address that is "en route" to "the internet":
      my $address      = Net::Address::IP::Local->public;
      my $address_ipv4 = Net::Address::IP::Local->public_ipv4;
      my $address_ipv6 = Net::Address::IP::Local->public_ipv6;
      
      # Get the local system's IP address that is "en route" to the given remote
      # IP address:
      my $address = Net::Address::IP::Local->connected_to($remote_address);
  
  =head1 DESCRIPTION
  
  B<Net::Address::IP::Local> discovers the local system's IP address that would
  be used as the source address when contacting "the internet" or a certain
  specified remote IP address.
  
  =cut
  
  # Implementation:
  ###############################################################################
  
  =head2 Class methods
  
  This class just provides the following class methods:
  
  =over
  
  =item B<public>: returns I<string>; throws I<Net::Address::IP::Local::Error>
  
  Returns the textual representation of the local system's IP address that is
  "en route" to "the internet".  If the system supports IPv6 and has an IPv6
  address that is "en route" to "the internet", that is returned.  Otherwise, the
  IPv4 address that is "en route" to "the internet" is returned.  If there is no
  route at all to the internet, a I<Net::Address::IP::Local::Error> exception is
  thrown.
  
  =cut
  
  sub public {
      my ($class) = @_;
      
      return $class->connected_to($class->remote_address_ipv4_default)
          if not $class->ipv6_support;
          # Short-cut for the common case with no IPv6 support.
      
      my $ip_address;
      
      try {
          $ip_address = $class->connected_to($class->remote_address_ipv6_default);
      }
      catch Net::Address::IP::Local::Error with {
          my $error = shift;
          try {
              $ip_address = $class->connected_to($class->remote_address_ipv4_default);
          }
          catch Net::Address::IP::Local::Error with {
              # If neither the IPv4 nor IPv6 local address could be determined,
              # re-throw the first error that occurred:
              $error->throw;
          };
      };
      
      return $ip_address;
  }
  
  =item B<public_ipv4>: returns I<string>; throws I<Net::Address::IP::Local::Error>
  
  Returns the textual representation of the local system's IPv4 address that is "en
  route" to "the internet".  If there is no IPv4 route to the internet, a
  I<Net::Address::IP::Local::Error> exception is thrown.
  
  =cut
  
  sub public_ipv4 {
      my ($class) = @_;
      $class->ipv4_support
          or throw Net::Address::IP::Local::Error("IPv4 not supported");
      return $class->connected_to($class->remote_address_ipv4_default);
  }
  
  =item B<public_ipv6>: returns I<string>; throws I<Net::Address::IP::Local::Error>
  
  Returns the textual representation of the local system's IPv6 address that is "en
  route" to "the internet".  If there is no IPv6 route to the internet, a
  I<Net::Address::IP::Local::Error> exception is thrown.
  
  =cut
  
  sub public_ipv6 {
      my ($class) = @_;
      $class->ipv6_support
          or throw Net::Address::IP::Local::Error("IPv6 not supported");
      return $class->connected_to($class->remote_address_ipv6_default);
  }
  
  =item B<connected_to($remote_address)>: returns I<string>; throws
  I<Net::Address::IP::Local::Error>
  
  Returns the textual representation of the local system's IP address that is "en
  route" to the given remote IP address.  If there is no route to the given
  remote IP address, a I<Net::Address::IP::Local::Error> exception is thrown.
  
  =cut
  
  sub connected_to {
      my ($class, $remote_address) = @_;
      
      my $socket_class;
      if ($class->ipv6_support) {
          $socket_class = 'IO::Socket::INET6';
      }
      elsif ($class->ipv4_support) {
          $socket_class = 'IO::Socket::INET';
      }
      else {
          throw Net::Address::IP::Local::Error("Neither IPv4 nor IPv6 supported");
      }
      
      my $socket = $socket_class->new(
          Proto       => 'udp',
          PeerAddr    => $remote_address,
          PeerPort    => $class->remote_port_default
      );
      
      defined($socket)
          or throw Net::Address::IP::Local::Error("Unable to create UDP socket: $!");
      
      return $socket->sockhost;
  }
  
  =back
  
  =cut
  
  # Private helper methods:
  
  my $ipv4_support;
  
  sub ipv4_support {
      if (not defined($ipv4_support)) {
          eval { require IO::Socket::INET };
          $ipv4_support = not $@;
      }
      return $ipv4_support;
  }
  
  my $ipv6_support;
  
  sub ipv6_support {
      if (not defined($ipv6_support)) {
          eval { require IO::Socket::INET6 };
          $ipv6_support = not $@;
      }
      return $ipv6_support;
  }
  
  =head1 AVAILABILITY and SUPPORT
  
  The latest version of Net::Address::IP::Local is available on CPAN and at
  L<http://www.mehnle.net/software/net-address-ip-local-perl>.
  
  Support is usually (but not guaranteed to be) given by the author, Julian
  Mehnle <julian@mehnle.net>.
  
  =head1 AUTHOR and LICENSE
  
  Net::Address::IP::Local is Copyright (C) 2005-2009 Julian Mehnle
  <julian@mehnle.net>.
  
  Net::Address::IP::Local is free software.  You may use, modify, and distribute
  it under the same terms as Perl itself, i.e. under the GNU GPL or the Artistic
  License.
  
  =cut
  
  package Net::Address::IP::Local::Error;
  use base qw(Error::Simple);
  
  package Net::Address::IP::Local;
  
  TRUE;
NET_ADDRESS_IP_LOCAL

$fatpacked{"Regexp/Common.pm"} = <<'REGEXP_COMMON';
  package Regexp::Common;
  
  use 5.00473;
  use strict;
  
  BEGIN {
      # This makes sure 'use warnings' doesn't bomb out on 5.005_*;
      # warnings won't be enabled on those old versions though.
      # Since all other files use this file, we can use 'use warnings'
      # elsewhere as well, but *AFTER* 'use Regexp::Common'.
      if ($] < 5.006) {
          $INC {"warnings.pm"} = 1;
          no strict 'refs';
          *{"warnings::unimport"} = sub {0};
      }
  }
  
  use warnings;
  use vars qw /$VERSION %RE %sub_interface $AUTOLOAD/;
  
  $VERSION = '2010010201';
  
  
  sub _croak {
      require Carp;
      goto &Carp::croak;
  }
  
  sub _carp {
      require Carp;
      goto &Carp::carp;
  }
  
  sub new {
      my ($class, @data) = @_;
      my %self;
      tie %self, $class, @data;
      return \%self;
  }
  
  sub TIEHASH {
      my ($class, @data) = @_;
      bless \@data, $class;
  }
  
  sub FETCH {
      my ($self, $extra) = @_;
      return bless ref($self)->new(@$self, $extra), ref($self);
  }
  
  my %imports = map {$_ => "Regexp::Common::$_"}
                qw /balanced CC     comment   delimited lingua list
                    net      number profanity SEN       URI    whitespace
                    zip/;
  
  sub import {
      shift;  # Shift off the class.
      tie %RE, __PACKAGE__;
      {
          no strict 'refs';
          *{caller() . "::RE"} = \%RE;
      }
  
      my $saw_import;
      my $no_defaults;
      my %exclude;
      foreach my $entry (grep {!/^RE_/} @_) {
          if ($entry eq 'pattern') {
              no strict 'refs';
              *{caller() . "::pattern"} = \&pattern;
              next;
          }
          # This used to prevent $; from being set. We still recognize it,
          # but we won't do anything.
          if ($entry eq 'clean') {
              next;
          }
          if ($entry eq 'no_defaults') {
              $no_defaults ++;
              next;
          }
          if (my $module = $imports {$entry}) {
              $saw_import ++;
              eval "require $module;";
              die $@ if $@;
              next;
          }
          if ($entry =~ /^!(.*)/ && $imports {$1}) {
              $exclude {$1} ++;
              next;
          }
          # As a last resort, try to load the argument.
          my $module = $entry =~ /^Regexp::Common/
                              ? $entry
                              : "Regexp::Common::" . $entry;
          eval "require $module;";
          die $@ if $@;
      }
  
      unless ($saw_import || $no_defaults) {
          foreach my $module (values %imports) {
              next if $exclude {$module};
              eval "require $module;";
              die $@ if $@;
          }
      }
  
      my %exported;
      foreach my $entry (grep {/^RE_/} @_) {
          if ($entry =~ /^RE_(\w+_)?ALL$/) {
              my $m  = defined $1 ? $1 : "";
              my $re = qr /^RE_${m}.*$/;
              while (my ($sub, $interface) = each %sub_interface) {
                  next if $exported {$sub};
                  next unless $sub =~ /$re/;
                  {
                      no strict 'refs';
                      *{caller() . "::$sub"} = $interface;
                  }
                  $exported {$sub} ++;
              }
          }
          else {
              next if $exported {$entry};
              _croak "Can't export unknown subroutine &$entry"
                  unless $sub_interface {$entry};
              {
                  no strict 'refs';
                  *{caller() . "::$entry"} = $sub_interface {$entry};
              }
              $exported {$entry} ++;
          }
      }
  }
  
  sub AUTOLOAD { _croak "Can't $AUTOLOAD" }
  
  sub DESTROY {}
  
  my %cache;
  
  my $fpat = qr/^(-\w+)/;
  
  sub _decache {
          my @args = @{tied %{$_[0]}};
          my @nonflags = grep {!/$fpat/} @args;
          my $cache = get_cache(@nonflags);
          _croak "Can't create unknown regex: \$RE{"
              . join("}{",@args) . "}"
                  unless exists $cache->{__VAL__};
          _croak "Perl $] does not support the pattern "
              . "\$RE{" . join("}{",@args)
              . "}.\nYou need Perl $cache->{__VAL__}{version} or later"
                  unless ($cache->{__VAL__}{version}||0) <= $];
          my %flags = ( %{$cache->{__VAL__}{default}},
                        map { /$fpat\Q$;\E(.*)/ ? ($1 => $2)
                            : /$fpat/           ? ($1 => undef)
                            :                     ()
                            } @args);
          $cache->{__VAL__}->_clone_with(\@args, \%flags);
  }
  
  use overload q{""} => \&_decache;
  
  
  sub get_cache {
          my $cache = \%cache;
          foreach (@_) {
                  $cache = $cache->{$_}
                        || ($cache->{$_} = {});
          }
          return $cache;
  }
  
  sub croak_version {
          my ($entry, @args) = @_;
  }
  
  sub pattern {
          my %spec = @_;
          _croak 'pattern() requires argument: name => [ @list ]'
                  unless $spec{name} && ref $spec{name} eq 'ARRAY';
          _croak 'pattern() requires argument: create => $sub_ref_or_string'
                  unless $spec{create};
  
          if (ref $spec{create} ne "CODE") {
                  my $fixed_str = "$spec{create}";
                  $spec{create} = sub { $fixed_str }
          }
  
          my @nonflags;
          my %default;
          foreach ( @{$spec{name}} ) {
                  if (/$fpat=(.*)/) {
                          $default{$1} = $2;
                  }
                  elsif (/$fpat\s*$/) {
                          $default{$1} = undef;
                  }
                  else {
                          push @nonflags, $_;
                  }
          }
  
          my $entry = get_cache(@nonflags);
  
          if ($entry->{__VAL__}) {
                  _carp "Overriding \$RE{"
                     . join("}{",@nonflags)
                     . "}";
          }
  
          $entry->{__VAL__} = bless {
                                  create  => $spec{create},
                                  match   => $spec{match} || \&generic_match,
                                  subs    => $spec{subs}  || \&generic_subs,
                                  version => $spec{version},
                                  default => \%default,
                              }, 'Regexp::Common::Entry';
  
          foreach (@nonflags) {s/\W/X/g}
          my $subname = "RE_" . join ("_", @nonflags);
          $sub_interface{$subname} = sub {
                  push @_ => undef if @_ % 2;
                  my %flags = @_;
                  my $pat = $spec{create}->($entry->{__VAL__},
                                 {%default, %flags}, \@nonflags);
                  if (exists $flags{-keep}) { $pat =~ s/\Q(?k:/(/g; }
                  else { $pat =~ s/\Q(?k:/(?:/g; }
                  return exists $flags {-i} ? qr /(?i:$pat)/ : qr/$pat/;
          };
  
          return 1;
  }
  
  sub generic_match {$_ [1] =~  /$_[0]/}
  sub generic_subs  {$_ [1] =~ s/$_[0]/$_[2]/}
  
  sub matches {
          my ($self, $str) = @_;
          my $entry = $self -> _decache;
          $entry -> {match} -> ($entry, $str);
  }
  
  sub subs {
          my ($self, $str, $newstr) = @_;
          my $entry = $self -> _decache;
          $entry -> {subs} -> ($entry, $str, $newstr);
          return $str;
  }
  
  
  package Regexp::Common::Entry;
  # use Carp;
  
  use overload
      q{""} => sub {
          my ($self) = @_;
          my $pat = $self->{create}->($self, $self->{flags}, $self->{args});
          if (exists $self->{flags}{-keep}) {
              $pat =~ s/\Q(?k:/(/g;
          }
          else {
              $pat =~ s/\Q(?k:/(?:/g;
          }
          if (exists $self->{flags}{-i})   { $pat = "(?i)$pat" }
          return $pat;
      };
  
  sub _clone_with {
      my ($self, $args, $flags) = @_;
      bless { %$self, args=>$args, flags=>$flags }, ref $self;
  }
  
  
  =pod
  
  =head1 NAME
  
  Regexp::Common - Provide commonly requested regular expressions
  
  =head1 SYNOPSIS
  
   # STANDARD USAGE 
  
   use Regexp::Common;
  
   while (<>) {
       /$RE{num}{real}/               and print q{a number};
       /$RE{quoted}                   and print q{a ['"`] quoted string};
       /$RE{delimited}{-delim=>'/'}/  and print q{a /.../ sequence};
       /$RE{balanced}{-parens=>'()'}/ and print q{balanced parentheses};
       /$RE{profanity}/               and print q{a #*@%-ing word};
   }
  
  
   # SUBROUTINE-BASED INTERFACE
  
   use Regexp::Common 'RE_ALL';
  
   while (<>) {
       $_ =~ RE_num_real()              and print q{a number};
       $_ =~ RE_quoted()                and print q{a ['"`] quoted string};
       $_ =~ RE_delimited(-delim=>'/')  and print q{a /.../ sequence};
       $_ =~ RE_balanced(-parens=>'()'} and print q{balanced parentheses};
       $_ =~ RE_profanity()             and print q{a #*@%-ing word};
   }
  
  
   # IN-LINE MATCHING...
  
   if ( $RE{num}{int}->matches($text) ) {...}
  
  
   # ...AND SUBSTITUTION
  
   my $cropped = $RE{ws}{crop}->subs($uncropped);
  
  
   # ROLL-YOUR-OWN PATTERNS
  
   use Regexp::Common 'pattern';
  
   pattern name   => ['name', 'mine'],
           create => '(?i:J[.]?\s+A[.]?\s+Perl-Hacker)',
           ;
  
   my $name_matcher = $RE{name}{mine};
  
   pattern name    => [ 'lineof', '-char=_' ],
           create  => sub {
                          my $flags = shift;
                          my $char = quotemeta $flags->{-char};
                          return '(?:^$char+$)';
                      },
           matches => sub {
                          my ($self, $str) = @_;
                          return $str !~ /[^$self->{flags}{-char}]/;
                      },
           subs   => sub {
                          my ($self, $str, $replacement) = @_;
                          $_[1] =~ s/^$self->{flags}{-char}+$//g;
                     },
           ;
  
   my $asterisks = $RE{lineof}{-char=>'*'};
  
   # DECIDING WHICH PATTERNS TO LOAD.
  
   use Regexp::Common qw /comment number/;  # Comment and number patterns.
   use Regexp::Common qw /no_defaults/;     # Don't load any patterns.
   use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
  
  
  =head1 DESCRIPTION
  
  By default, this module exports a single hash (C<%RE>) that stores or generates
  commonly needed regular expressions (see L<"List of available patterns">).
  
  There is an alternative, subroutine-based syntax described in
  L<"Subroutine-based interface">.
  
  
  =head2 General syntax for requesting patterns
  
  To access a particular pattern, C<%RE> is treated as a hierarchical hash of
  hashes (of hashes...), with each successive key being an identifier. For
  example, to access the pattern that matches real numbers, you 
  specify:
  
          $RE{num}{real}
          
  and to access the pattern that matches integers: 
  
          $RE{num}{int}
  
  Deeper layers of the hash are used to specify I<flags>: arguments that
  modify the resulting pattern in some way. The keys used to access these
  layers are prefixed with a minus sign and may have a value; if a value
  is given, it's done by using a multidimensional key.
  For example, to access the pattern that
  matches base-2 real numbers with embedded commas separating
  groups of three digits (e.g. 10,101,110.110101101):
  
          $RE{num}{real}{-base => 2}{-sep => ','}{-group => 3}
  
  Through the magic of Perl, these flag layers may be specified in any order
  (and even interspersed through the identifier keys!)
  so you could get the same pattern with:
  
          $RE{num}{real}{-sep => ','}{-group => 3}{-base => 2}
  
  or:
  
          $RE{num}{-base => 2}{real}{-group => 3}{-sep => ','}
  
  or even:
  
          $RE{-base => 2}{-group => 3}{-sep => ','}{num}{real}
  
  etc.
  
  Note, however, that the relative order of amongst the identifier keys
  I<is> significant. That is:
  
          $RE{list}{set}
  
  would not be the same as:
  
          $RE{set}{list}
  
  =head2 Flag syntax
  
  In versions prior to 2.113, flags could also be written as
  C<{"-flag=value"}>. This no longer works, although C<{"-flag$;value"}>
  still does. However, C<< {-flag => 'value'} >> is the preferred syntax.
  
  =head2 Universal flags
  
  Normally, flags are specific to a single pattern.
  However, there is two flags that all patterns may specify.
  
  =over 4
  
  =item C<-keep>
  
  By default, the patterns provided by C<%RE> contain no capturing
  parentheses. However, if the C<-keep> flag is specified (it requires
  no value) then any significant substrings that the pattern matches
  are captured. For example:
  
          if ($str =~ $RE{num}{real}{-keep}) {
                  $number   = $1;
                  $whole    = $3;
                  $decimals = $5;
          }
  
  Special care is needed if a "kept" pattern is interpolated into a
  larger regular expression, as the presence of other capturing
  parentheses is likely to change the "number variables" into which significant
  substrings are saved.
  
  See also L<"Adding new regular expressions">, which describes how to create
  new patterns with "optional" capturing brackets that respond to C<-keep>.
  
  =item C<-i>
  
  Some patterns or subpatterns only match lowercase or uppercase letters.
  If one wants the do case insensitive matching, one option is to use
  the C</i> regexp modifier, or the special sequence C<(?i)>. But if the
  functional interface is used, one does not have this option. The 
  C<-i> switch solves this problem; by using it, the pattern will do
  case insensitive matching.
  
  =back
  
  =head2 OO interface and inline matching/substitution
  
  The patterns returned from C<%RE> are objects, so rather than writing:
  
          if ($str =~ /$RE{some}{pattern}/ ) {...}
  
  you can write:
  
          if ( $RE{some}{pattern}->matches($str) ) {...}
  
  For matching this would seem to have no great advantage apart from readability
  (but see below).
  
  For substitutions, it has other significant benefits. Frequently you want to
  perform a substitution on a string without changing the original. Most people
  use this:
  
          $changed = $original;
          $changed =~ s/$RE{some}{pattern}/$replacement/;
  
  The more adept use:
  
          ($changed = $original) =~ s/$RE{some}{pattern}/$replacement/;
  
  Regexp::Common allows you do write this:
  
          $changed = $RE{some}{pattern}->subs($original=>$replacement);
  
  Apart from reducing precedence-angst, this approach has the added
  advantages that the substitution behaviour can be optimized from the 
  regular expression, and the replacement string can be provided by
  default (see L<"Adding new regular expressions">).
  
  For example, in the implementation of this substitution:
  
          $cropped = $RE{ws}{crop}->subs($uncropped);
  
  the default empty string is provided automatically, and the substitution is
  optimized to use:
  
          $uncropped =~ s/^\s+//;
          $uncropped =~ s/\s+$//;
  
  rather than:
  
          $uncropped =~ s/^\s+|\s+$//g;
  
  
  =head2 Subroutine-based interface
  
  The hash-based interface was chosen because it allows regexes to be
  effortlessly interpolated, and because it also allows them to be
  "curried". For example:
  
          my $num = $RE{num}{int};
  
          my $commad     = $num->{-sep=>','}{-group=>3};
          my $duodecimal = $num->{-base=>12};
  
  
  However, the use of tied hashes does make the access to Regexp::Common
  patterns slower than it might otherwise be. In contexts where impatience
  overrules laziness, Regexp::Common provides an additional
  subroutine-based interface.
  
  For each (sub-)entry in the C<%RE> hash (C<$RE{key1}{key2}{etc}>), there
  is a corresponding exportable subroutine: C<RE_key1_key2_etc()>. The name of
  each subroutine is the underscore-separated concatenation of the I<non-flag>
  keys that locate the same pattern in C<%RE>. Flags are passed to the subroutine
  in its argument list. Thus:
  
          use Regexp::Common qw( RE_ws_crop RE_num_real RE_profanity );
  
          $str =~ RE_ws_crop() and die "Surrounded by whitespace";
  
          $str =~ RE_num_real(-base=>8, -sep=>" ") or next;
  
          $offensive = RE_profanity(-keep);
          $str =~ s/$offensive/$bad{$1}++; "<expletive deleted>"/ge;
  
  Note that, unlike the hash-based interface (which returns objects), these
  subroutines return ordinary C<qr>'d regular expressions. Hence they do not
  curry, nor do they provide the OO match and substitution inlining described
  in the previous section.
  
  It is also possible to export subroutines for all available patterns like so:
  
          use Regexp::Common 'RE_ALL';
  
  Or you can export all subroutines with a common prefix of keys like so:
  
          use Regexp::Common 'RE_num_ALL';
  
  which will export C<RE_num_int> and C<RE_num_real> (and if you have
  create more patterns who have first key I<num>, those will be exported
  as well). In general, I<RE_key1_..._keyn_ALL> will export all subroutines
  whose pattern names have first keys I<key1> ... I<keyn>.
  
  
  =head2 Adding new regular expressions
  
  You can add your own regular expressions to the C<%RE> hash at run-time,
  using the exportable C<pattern> subroutine. It expects a hash-like list of 
  key/value pairs that specify the behaviour of the pattern. The various
  possible argument pairs are:
  
  =over 4
  
  =item C<name =E<gt> [ @list ]>
  
  A required argument that specifies the name of the pattern, and any
  flags it may take, via a reference to a list of strings. For example:
  
           pattern name => [qw( line of -char )],
                   # other args here
                   ;
  
  This specifies an entry C<$RE{line}{of}>, which may take a C<-char> flag.
  
  Flags may also be specified with a default value, which is then used whenever
  the flag is specified without an explicit value (but not when the flag is
  omitted). For example:
  
           pattern name => [qw( line of -char=_ )],
                   # default char is '_'
                   # other args here
                   ;
  
  
  =item C<create =E<gt> $sub_ref_or_string>
  
  A required argument that specifies either a string that is to be returned
  as the pattern:
  
          pattern name    => [qw( line of underscores )],
                  create  => q/(?:^_+$)/
                  ;
  
  or a reference to a subroutine that will be called to create the pattern:
  
          pattern name    => [qw( line of -char=_ )],
                  create  => sub {
                                  my ($self, $flags) = @_;
                                  my $char = quotemeta $flags->{-char};
                                  return '(?:^$char+$)';
                              },
                  ;
  
  If the subroutine version is used, the subroutine will be called with 
  three arguments: a reference to the pattern object itself, a reference
  to a hash containing the flags and their values,
  and a reference to an array containing the non-flag keys. 
  
  Whatever the subroutine returns is stringified as the pattern.
  
  No matter how the pattern is created, it is immediately postprocessed to
  include or exclude capturing parentheses (according to the value of the
  C<-keep> flag). To specify such "optional" capturing parentheses within
  the regular expression associated with C<create>, use the notation
  C<(?k:...)>. Any parentheses of this type will be converted to C<(...)>
  when the C<-keep> flag is specified, or C<(?:...)> when it is not.
  It is a Regexp::Common convention that the outermost capturing parentheses
  always capture the entire pattern, but this is not enforced.
  
  
  =item C<matches =E<gt> $sub_ref>
  
  An optional argument that specifies a subroutine that is to be called when
  the C<$RE{...}-E<gt>matches(...)> method of this pattern is invoked.
  
  The subroutine should expect two arguments: a reference to the pattern object
  itself, and the string to be matched against.
  
  It should return the same types of values as a C<m/.../> does.
  
       pattern name    => [qw( line of -char )],
               create  => sub {...},
               matches => sub {
                               my ($self, $str) = @_;
                               $str !~ /[^$self->{flags}{-char}]/;
                          },
               ;
  
  
  =item C<subs =E<gt> $sub_ref>
  
  An optional argument that specifies a subroutine that is to be called when
  the C<$RE{...}-E<gt>subs(...)> method of this pattern is invoked.
  
  The subroutine should expect three arguments: a reference to the pattern object
  itself, the string to be changed, and the value to be substituted into it.
  The third argument may be C<undef>, indicating the default substitution is
  required.
  
  The subroutine should return the same types of values as an C<s/.../.../> does.
  
  For example:
  
       pattern name    => [ 'lineof', '-char=_' ],
               create  => sub {...},
               subs    => sub {
                            my ($self, $str, $ignore_replacement) = @_;
                            $_[1] =~ s/^$self->{flags}{-char}+$//g;
                          },
               ;
  
  Note that such a subroutine will almost always need to modify C<$_[1]> directly.
  
  
  =item C<version =E<gt> $minimum_perl_version>
  
  If this argument is given, it specifies the minimum version of perl required
  to use the new pattern. Attempts to use the pattern with earlier versions of
  perl will generate a fatal diagnostic.
  
  =back
  
  =head2 Loading specific sets of patterns.
  
  By default, all the sets of patterns listed below are made available.
  However, it is possible to indicate which sets of patterns should
  be made available - the wanted sets should be given as arguments to
  C<use>. Alternatively, it is also possible to indicate which sets of
  patterns should not be made available - those sets will be given as
  argument to the C<use> statement, but are preceeded with an exclaimation
  mark. The argument I<no_defaults> indicates none of the default patterns
  should be made available. This is useful for instance if all you want
  is the C<pattern()> subroutine.
  
  Examples:
  
   use Regexp::Common qw /comment number/;  # Comment and number patterns.
   use Regexp::Common qw /no_defaults/;     # Don't load any patterns.
   use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
  
  It's also possible to load your own set of patterns. If you have a
  module C<Regexp::Common::my_patterns> that makes patterns available,
  you can have it made available with
  
   use Regexp::Common qw /my_patterns/;
  
  Note that the default patterns will still be made available - only if
  you use I<no_defaults>, or mention one of the default sets explicitely,
  the non mentioned defaults aren't made available.
  
  =head2 List of available patterns
  
  The patterns listed below are currently available. Each set of patterns
  has its own manual page describing the details. For each pattern set
  named I<name>, the manual page I<Regexp::Common::name> describes the
  details.
  
  Currently available are:
  
  =over 4
  
  =item Regexp::Common::balanced
  
  Provides regexes for strings with balanced parenthesized delimiters.
  
  =item Regexp::Common::comment
  
  Provides regexes for comments of various languages (43 languages
  currently).
  
  =item Regexp::Common::delimited
  
  Provides regexes for delimited strings.
  
  =item Regexp::Common::lingua
  
  Provides regexes for palindromes.
  
  =item Regexp::Common::list
  
  Provides regexes for lists.
  
  =item Regexp::Common::net
  
  Provides regexes for IPv4 addresses and MAC addresses.
  
  =item Regexp::Common::number
  
  Provides regexes for numbers (integers and reals).
  
  =item Regexp::Common::profanity
  
  Provides regexes for profanity.
  
  =item Regexp::Common::whitespace
  
  Provides regexes for leading and trailing whitespace.
  
  =item Regexp::Common::zip
  
  Provides regexes for zip codes.
  
  =back
  
  =head2 Forthcoming patterns and features
  
  Future releases of the module will also provide patterns for the following:
  
          * email addresses 
          * HTML/XML tags
          * more numerical matchers,
          * mail headers (including multiline ones),
          * more URLS
          * telephone numbers of various countries
          * currency (universal 3 letter format, Latin-1, currency names)
          * dates
          * binary formats (e.g. UUencoded, MIMEd)
  
  If you have other patterns or pattern generators that you think would be
  generally useful, please send them to the maintainer -- preferably as source
  code using the C<pattern> subroutine. Submissions that include a set of
  tests will be especially welcome.
  
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item C<Can't export unknown subroutine %s>
  
  The subroutine-based interface didn't recognize the requested subroutine.
  Often caused by a spelling mistake or an incompletely specified name.
  
          
  =item C<Can't create unknown regex: $RE{...}>
  
  Regexp::Common doesn't have a generator for the requested pattern.
  Often indicates a mispelt or missing parameter.
  
  =item
  C<Perl %f does not support the pattern $RE{...}.
  You need Perl %f or later>
  
  The requested pattern requires advanced regex features (e.g. recursion)
  that not available in your version of Perl. Time to upgrade.
  
  =item C<< pattern() requires argument: name => [ @list ] >>
  
  Every user-defined pattern specification must have a name.
  
  =item C<< pattern() requires argument: create => $sub_ref_or_string >>
  
  Every user-defined pattern specification must provide a pattern creation
  mechanism: either a pattern string or a reference to a subroutine that
  returns the pattern string.
  
  =item C<Base must be between 1 and 36>
  
  The C<< $RE{num}{real}{-base=>'I<N>'} >> pattern uses the characters [0-9A-Z]
  to represent the digits of various bases. Hence it only produces
  regular expressions for bases up to hexatricensimal.
  
  =item C<Must specify delimiter in $RE{delimited}>
  
  The pattern has no default delimiter.
  You need to write: C<< $RE{delimited}{-delim=>I<X>'} >> for some character I<X>
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  Deepest thanks to the many people who have encouraged and contributed to this
  project, especially: Elijah, Jarkko, Tom, Nat, Ed, and Vivek.
  
  Further thanks go to: Alexandr Ciornii, Blair Zajac, Bob Stockdale,
  Charles Thomas, Chris Vertonghen, the CPAN Testers, David Hand,
  Fany, Geoffrey Leach, Hermann-Marcus Behrens, Jerome Quelin, Jim Cromie,
  Lars Wilke, Linda Julien, Mike Arms, Mike Castle, Mikko, Murat Uenalan,
  RafaE<235>l Garcia-Suarez, Ron Savage, Sam Vilain, Slaven Rezic, Smylers,
  Tim Maher, and all the others I've forgotten.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  There are some POD issues when installing this module using a pre-5.6.0 perl;
  some manual pages may not install, or may not install correctly using a perl
  that is that old. You might consider upgrading your perl.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
REGEXP_COMMON

$fatpacked{"Regexp/Common/CC.pm"} = <<'REGEXP_COMMON_CC';
  package Regexp::Common::CC;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  use Regexp::Common::_support qw /luhn/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  my @cards = (
      # Name           Prefix                    Length           mod 10
      [Mastercard   =>   '5[1-5]',                16,                1],
      [Visa         =>   '4',                     [13, 16],          1],
      [Amex         =>   '3[47]',                 15,                1],
     # Carte Blanche
     ['Diners Club' =>   '3(?:0[0-5]|[68])',      14,                1],
      [Discover     =>   '6011',                  16,                1],
      [enRoute      =>   '2(?:014|149)',          15,                0],
      [JCB          => [['3',                     16,                1],
                        ['2131|1800',             15,                1]]],
  );
  
  
  foreach my $card (@cards) {
      my ($name, $prefix, $length, $mod) = @$card;
  
      # Skip the harder ones for now.
      next if ref $prefix || ref $length;
      next unless $mod;
  
      my $times = $length + $mod;
      pattern name    => [CC => $name],
              version => 5.006,
              create  => sub {
                  use re 'eval';
                  qr <((?=($prefix))[0-9]{$length})
                      (?(?{Regexp::Common::_support::luhn $1})|(?!))>x
              }
      ;
  }
  
  
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::CC -- provide patterns for credit card numbers.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /CC/;
  
      while (<>) {
          /^$RE{CC}{Mastercard}$/   and  print "Mastercard card number\n";
      }
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  This module offers patterns for credit card numbers of several major
  credit card types. Currently, the supported cards are: I<Mastercard>,
  I<Amex>, I<Diners Club>, and I<Discover>.
  
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =over 4
  
  =item L<http://www.beachnet.com/~hstiles/cardtype.html>
  
  Credit Card Validation - Check Digits 
  
  =item L<http://euro.ecom.cmu.edu/resources/elibrary/everycc.htm>
  
  Everything you ever wanted to know about CC's
  
  =item L<http://www.webopedia.com/TERM/L/Luhn_formula.html>
  
  Luhn formula
  
  =back
  
  =head1 AUTHORS
  
  Damian Conway S<(I<damian@conway.org>)> and
  Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty. Send them in to S<I<regexp-common@abigail.be>>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_CC

$fatpacked{"Regexp/Common/SEN.pm"} = <<'REGEXP_COMMON_SEN';
  package Regexp::Common::SEN;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  =begin does_not_exist
  
  sub par11 {
      my $string = shift;
      my $sum    = 0;
      for my $i (0 .. length ($string) - 1) {
          my $c = substr ($string, $i, 1);
          $sum += $c * (length ($string) - $i)
      }
      !($sum % 11)
  }
  
  =end does_not_exist
  =cut
  
  # http://www.ssa.gov/history/ssn/geocard.html
  pattern name   => [qw /SEN USA SSN -sep=-/],
          create => sub {
              my $sep = $_ [1] {-sep};
              "(?k:(?k:[1-9][0-9][0-9]|0[1-9][0-9]|00[1-9])$sep"   .
                  "(?k:[1-9][0-9]|0[1-9])$sep"                     .
                  "(?k:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|"     .
                                           "00[1-9][0-9]|000[1-9]))"
          },
          ;
  
  =begin does_not_exist
  
  It's not clear whether this is the right checksum.
  
  # http://www.google.nl/search?q=cache:8m1zKNYrEO0J:www.enschede.nl/nieuw/projecten/aanbesteding/integratie/pve%2520Bijlage%25207.5.doc+Sofi+nummer+formaat&hl=en&start=56&lr=lang_en|lang_nl&ie=UTF-8
  pattern name   => [qw /SEN Netherlands SoFi/],
          create => sub {
              # 9 digits (d1 d2 d3 d4 d5 d6 d7 d8 d9)
              # 9*d1 + 8*d2 + 7*d3 + 6*d4 + 5*d5 + 4*d6 + 3*d7 + 2*d8 + 1*d9 
              # == 0 mod 11.
              qr /([0-9]{9})(?(?{par11 ($^N)})|(?!))/;
          }
          ;
  
  =end does_not_exist
  =cut
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::SEN -- provide regexes for Social-Economical Numbers.
  
  =head1 SYNOPSIS
  
   use Regexp::Common qw /SEN/;
  
   while (<>) {
       /^$RE{SEN}{USA}{SSN}$/    and  print "Social Security Number\n";
   }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{SEN}{USA}{SSN}{-sep}>
  
  Returns a pattern that matches an American Social Security Number (SSN).
  SSNs consist of three groups of numbers, separated by a hypen (C<->).
  This pattern only checks for a valid structure, that is, it validates
  whether a number is valid SSN, was a valid SSN, or maybe a valid SSN
  in the future. There are almost a billion possible SSNs, and about 
  400 million are in use, or have been in use. 
  
  If C<-sep=I<P>> is specified, the pattern I<P> is used as the
  separator between the groups of numbers.
  
  Under C<-keep> (see L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire SSN.
  
  =item $2
  
  captures the first group of digits (the area number).
  
  =item $3
  
  captures the second group of digits (the group number).
  
  =item $4
  
  captures the third group of digits (the serial number).
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHORS
  
  Damian Conway and Abigail.
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_SEN

$fatpacked{"Regexp/Common/URI.pm"} = <<'REGEXP_COMMON_URI';
  package Regexp::Common::URI;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use Exporter ();
  use vars qw /@EXPORT_OK @ISA/;
  
  @ISA       = qw /Exporter/;
  @EXPORT_OK = qw /register_uri/;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  # Use 'require' here, not 'use', so we delay running them after we are compiled.
  # We also do it using an 'eval'; this saves us from have repeated similar
  # lines. The eval is further explained in 'perldoc -f require'.
  my @uris = qw /fax file ftp gopher http pop prospero news tel telnet tv wais/;
  foreach my $uri (@uris) {
      eval "require Regexp::Common::URI::$uri";
      die $@ if $@;
  }
  
  my %uris;
  
  sub register_uri {
      my ($scheme, $uri) = @_;
      $uris {$scheme} = $uri;
  }
  
  pattern name    => [qw (URI)],
          create  => sub {my $uri =  join '|' => values %uris;
                             $uri =~ s/\(\?k:/(?:/g;
                        "(?k:$uri)";
          },
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI -- provide patterns for URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{HTTP}/       and  print "Contains an HTTP URI.\n";
      }
  
  =head1 DESCRIPTION
  
  Patterns for the following URIs are supported: fax, file, FTP, gopher,
  HTTP, news, NTTP, pop, prospero, tel, telnet, tv and WAIS.
  Each is documented in the I<Regexp::Common::URI::B<scheme>>,
  manual page, for the appropriate scheme (in lowercase), except for
  I<NNTP> URIs which are found in I<Regexp::Common::URI::news>.
  
  =head2 C<$RE{URI}>
  
  Return a pattern that recognizes any of the supported URIs. With
  C<{-keep}>, only the entire URI is returned (in C<$1>).
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[DRAFT-URI-TV]>
  
  Zigmond, D. and Vickers, M: I<Uniform Resource Identifiers for
  Television Broadcasts>. December 2000.
  
  =item B<[DRAFT-URL-FTP]>
  
  Casey, James: I<A FTP URL Format>. November 1996.
  
  =item B<[RFC 1035]>
  
  Mockapetris, P.: I<DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION>.
  November 1987.
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =item B<[RFC 2616]>
  
  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
  Leach, P. and Berners-Lee, Tim: I<Hypertext Transfer Protocol -- HTTP/1.1>.
  June 1999.
  
  =item B<[RFC 2806]>
  
  Vaha-Sipila, A.: I<URLs for Telephone Calls>. April 2000.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI

$fatpacked{"Regexp/Common/URI/RFC1035.pm"} = <<'REGEXP_COMMON_URI_RFC1035';
  package Regexp::Common::URI::RFC1035;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$digit $letter $let_dig $let_dig_hyp $ldh_str/];
      $vars {parts}   = [qw /$label $subdomain/];
      $vars {domain}  = [qw /$domain/];
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = qw /$host/;
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  # RFC 1035.
  $digit             = "[0-9]";
  $letter            = "[A-Za-z]";
  $let_dig           = "[A-Za-z0-9]";
  $let_dig_hyp       = "[-A-Za-z0-9]";
  $ldh_str           = "(?:[-A-Za-z0-9]+)";
  $label             = "(?:$letter(?:(?:$ldh_str){0,61}$let_dig)?)";
  $subdomain         = "(?:$label(?:[.]$label)*)";
  $domain            = "(?: |(?:$subdomain))";
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC1035 -- Definitions from RFC1035;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC1035 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC1035. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1035]>
  
  Mockapetris, P.: I<DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION>.
  November 1987.
  
  =back
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_RFC1035

$fatpacked{"Regexp/Common/URI/RFC1738.pm"} = <<'REGEXP_COMMON_URI_RFC1738';
  package Regexp::Common::URI::RFC1738;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$digit $digits $hialpha $lowalpha $alpha $alphadigit
                             $safe $extra $national $punctuation $unreserved
                             $unreserved_range $reserved $uchar $uchars $xchar
                             $xchars $hex $escape/];
  
      $vars {connect} = [qw /$port $hostnumber $toplabel $domainlabel $hostname
                             $host $hostport $user $password $login/];
  
      $vars {parts}   = [qw /$fsegment $fpath $group $article $grouppart
                             $search $database $wtype $wpath $psegment
                             $fieldname $fieldvalue $fieldspec $ppath/];
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = qw /$host/;
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  # RFC 1738, base definitions.
  
  # Lowlevel definitions.
  $digit             =  '[0-9]';
  $digits            =  '[0-9]+';
  $hialpha           =  '[A-Z]';
  $lowalpha          =  '[a-z]';
  $alpha             =  '[a-zA-Z]';                 # lowalpha | hialpha
  $alphadigit        =  '[a-zA-Z0-9]';              # alpha    | digit
  $safe              =  '[-$_.+]';
  $extra             =  "[!*'(),]";
  $national          =  '[][{}|\\^~`]';
  $punctuation       =  '[<>#%"]';
  $unreserved_range  = q [-a-zA-Z0-9$_.+!*'(),];  # alphadigit | safe | extra
  $unreserved        =  "[$unreserved_range]";
  $reserved          =  '[;/?:@&=]';
  $hex               =  '[a-fA-F0-9]';
  $escape            =  "(?:%$hex$hex)";
  $uchar             =  "(?:$unreserved|$escape)";
  $uchars            =  "(?:(?:$unreserved|$escape)*)";
  $xchar             =  "(?:[$unreserved_range;/?:\@&=]|$escape)";
  $xchars            =  "(?:(?:[$unreserved_range;/?:\@&=]|$escape)*)";
  
  # Connection related stuff.
  $port              =  "(?:$digits)";
  $hostnumber        =  "(?:$digits\[.]$digits\[.]$digits\[.]$digits)";
  $toplabel          =  "(?:$alpha\[-a-zA-Z0-9]*$alphadigit|$alpha)";
  $domainlabel       =  "(?:(?:$alphadigit\[-a-zA-Z0-9]*)?$alphadigit)";
  $hostname          =  "(?:(?:$domainlabel\[.])*$toplabel)";
  $host              =  "(?:$hostname|$hostnumber)";
  $hostport          =  "(?:$host(?::$port)?)";
  
  $user              =  "(?:(?:[$unreserved_range;?&=]|$escape)*)";
  $password          =  "(?:(?:[$unreserved_range;?&=]|$escape)*)";
  $login             =  "(?:(?:$user(?::$password)?\@)?$hostport)";
  
  # Parts (might require more if we add more URIs).
  
  # FTP/file
  $fsegment          =  "(?:(?:[$unreserved_range:\@&=]|$escape)*)";
  $fpath             =  "(?:$fsegment(?:/$fsegment)*)";
  
  # NNTP/news.
  $group             =  "(?:$alpha\[-A-Za-z0-9.+_]*)";
  $article           =  "(?:(?:[$unreserved_range;/?:&=]|$escape)+" .
                        '@' . "$host)";
  $grouppart         =  "(?:[*]|$article|$group)"; # It's important that
                                                   # $article goes before
                                                   # $group.
  
  # WAIS.
  $search            =  "(?:(?:[$unreserved_range;:\@&=]|$escape)*)";
  $database          =  $uchars;
  $wtype             =  $uchars;
  $wpath             =  $uchars;
  
  # prospero
  $psegment          =  "(?:(?:[$unreserved_range?:\@&=]|$escape)*)";
  $fieldname         =  "(?:(?:[$unreserved_range?:\@&]|$escape)*)";
  $fieldvalue        =  "(?:(?:[$unreserved_range?:\@&]|$escape)*)";
  $fieldspec         =  "(?:;$fieldname=$fieldvalue)";
  $ppath             =  "(?:$psegment(?:/$psegment)*)";
  
  #
  # The various '(?:(?:[$unreserved_range ...]|$escape)*)' above need
  # some loop unrolling to speed up the match.
  #
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC1738 -- Definitions from RFC1738;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC1738 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC1738. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 AUTHOR
  
  Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_RFC1738

$fatpacked{"Regexp/Common/URI/RFC1808.pm"} = <<'REGEXP_COMMON_URI_RFC1808';
  package Regexp::Common::URI::RFC1808;
  
  BEGIN {
      # This makes sure 'use warnings' doesn't bomb out on 5.005_*;
      # warnings won't be enabled on those old versions though.
      if ($] < 5.006 && !exists $INC {"warnings.pm"}) {
          $INC {"warnings.pm"} = 1;
          no strict 'refs';
          *{"warnings::unimport"} = sub {0};
      }
  }
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$punctuation $reserved_range $reserved $national
                             $extra $safe $digit $digits $hialpha $lowalpha
                             $alpha $alphadigit $hex $escape $unreserved_range
                             $unreserved $uchar $uchars $pchar_range $pchar
                             $pchars/],
  
      $vars {parts}   = [qw /$fragment $query $param $params $segment
                             $fsegment $path $net_loc $scheme $rel_path
                             $abs_path $net_path $relativeURL $generic_RL
                             $absoluteURL $URL/],
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = qw /$host/;
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  # RFC 1808, base definitions.
  
  # Lowlevel definitions.
  $punctuation       =  '[<>#%"]';
  $reserved_range    = q [;/?:@&=];
  $reserved          =  "[$reserved_range]";
  $national          =  '[][{}|\\^~`]';
  $extra             =  "[!*'(),]";
  $safe              =  '[-$_.+]';
  
  $digit             =  '[0-9]';
  $digits            =  '[0-9]+';
  $hialpha           =  '[A-Z]';
  $lowalpha          =  '[a-z]';
  $alpha             =  '[a-zA-Z]';                 # lowalpha | hialpha
  $alphadigit        =  '[a-zA-Z0-9]';              # alpha    | digit
  
  $hex               =  '[a-fA-F0-9]';
  $escape            =  "(?:%$hex$hex)";
  
  $unreserved_range  = q [-a-zA-Z0-9$_.+!*'(),];  # alphadigit | safe | extra
  $unreserved        =  "[$unreserved_range]";
  $uchar             =  "(?:$unreserved|$escape)";
  $uchars            =  "(?:(?:$unreserved+|$escape)*)";
  
  $pchar_range       = qq [$unreserved_range:\@&=];
  $pchar             =  "(?:[$pchar_range]|$escape)";
  $pchars            =  "(?:(?:[$pchar_range]+|$escape)*)";
  
  
  # Parts
  $fragment          =  "(?:(?:[$unreserved_range$reserved_range]+|$escape)*)";
  $query             =  "(?:(?:[$unreserved_range$reserved_range]+|$escape)*)";
  
  $param             =  "(?:(?:[$pchar_range/]+|$escape)*)";
  $params            =  "(?:$param(?:;$param)*)";
  
  $segment           =  "(?:(?:[$pchar_range]+|$escape)*)";
  $fsegment          =  "(?:(?:[$pchar_range]+|$escape)+)";
  $path              =  "(?:$fsegment(?:/$segment)*)";
  
  $net_loc           =  "(?:(?:[$pchar_range;?]+|$escape)*)";
  $scheme            =  "(?:(?:[-a-zA-Z0-9+.]+|$escape)+)";
  
  $rel_path          =  "(?:$path?(?:;$params)?(?:?$query)?)";
  $abs_path          =  "(?:/$rel_path)";
  $net_path          =  "(?://$net_loc$abs_path?)";
  
  $relativeURL       =  "(?:$net_path|$abs_path|$rel_path)";
  $generic_RL        =  "(?:$scheme:$relativeURL)";
  $absoluteURL       =  "(?:$generic_RL|" .
                  "(?:$scheme:(?:[$unreserved_range$reserved_range]+|$escape)*))";
  $URL               =  "(?:(?:$absoluteURL|$relativeURL)(?:#$fragment)?)";
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC1808 -- Definitions from RFC1808;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC1808 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC1808. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1808]>
  
  Fielding, R.: I<Relative Uniform Resource Locators (URL)>. June 1995.
  
  =back
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_RFC1808

$fatpacked{"Regexp/Common/URI/RFC2384.pm"} = <<'REGEXP_COMMON_URI_RFC2384';
  package Regexp::Common::URI::RFC2384;
  
  
  use Regexp::Common qw /pattern clean no_defaults/;
  use Regexp::Common::URI::RFC1738 qw /$unreserved_range $escape $hostport/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$achar_range $achar $achars $achar_more/];
      $vars {connect} = [qw /$enc_sasl $enc_user $enc_ext $enc_auth_type $auth
                             $user_auth $server/];
      $vars {parts}   = [qw /$pop_url/];
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = qw /$host/;
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  # RFC 2384, POP3.
  
  # Lowlevel definitions.
  $achar_range       =  "$unreserved_range&=~";
  $achar             =  "(?:[$achar_range]|$escape)";
  $achars            =  "(?:(?:[$achar_range]+|$escape)*)";
  $achar_more        =  "(?:(?:[$achar_range]+|$escape)+)";
  $enc_sasl          =  $achar_more;
  $enc_user          =  $achar_more;
  $enc_ext           =  "(?:[+](?:APOP|$achar_more))";
  $enc_auth_type     =  "(?:$enc_sasl|$enc_ext)";
  $auth              =  "(?:;AUTH=(?:[*]|$enc_auth_type))";
  $user_auth         =  "(?:$enc_user$auth?)";
  $server            =  "(?:(?:$user_auth\@)?$hostport)";
  $pop_url           =  "(?:pop://$server)";
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC2384 -- Definitions from RFC2384;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC2384 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC2384. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 2384]>
  
  Gellens, R.: I<POP URL scheme> August 1998.
  
  =back
  
  =head1 AUTHOR
  
  Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_RFC2384

$fatpacked{"Regexp/Common/URI/RFC2396.pm"} = <<'REGEXP_COMMON_URI_RFC2396';
  package Regexp::Common::URI::RFC2396;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$digit $upalpha $lowalpha $alpha $alphanum $hex
                             $escaped $mark $unreserved $reserved $pchar $uric
                             $urics $userinfo $userinfo_no_colon $uric_no_slash/];
      $vars {parts}   = [qw /$query $fragment $param $segment $path_segments
                             $ftp_segments $rel_segment $abs_path $rel_path
                             $path/];
      $vars {connect} = [qw /$port $IPv4address $toplabel $domainlabel $hostname
                             $host $hostport $server $reg_name $authority/];
      $vars {URI}     = [qw /$scheme $net_path $opaque_part $hier_part
                             $relativeURI $absoluteURI $URI_reference/];
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = ();
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  # RFC 2396, base definitions.
  $digit             =  '[0-9]';
  $upalpha           =  '[A-Z]';
  $lowalpha          =  '[a-z]';
  $alpha             =  '[a-zA-Z]';                # lowalpha | upalpha
  $alphanum          =  '[a-zA-Z0-9]';             # alpha    | digit
  $hex               =  '[a-fA-F0-9]';
  $escaped           =  "(?:%$hex$hex)";
  $mark              =  "[\\-_.!~*'()]";
  $unreserved        =  "[a-zA-Z0-9\\-_.!~*'()]";  # alphanum | mark
                        # %61-%7A, %41-%5A, %30-%39
                        #  a - z    A - Z    0 - 9
                        # %21, %27, %28, %29, %2A, %2D, %2E, %5F, %7E
                        #  !    '    (    )    *    -    .    _    ~
  $reserved          =  "[;/?:@&=+\$,]";
  $pchar             =  "(?:[a-zA-Z0-9\\-_.!~*'():\@&=+\$,]|$escaped)";
                                        # unreserved | escaped | [:@&=+$,]
  $uric              =  "(?:[;/?:\@&=+\$,a-zA-Z0-9\\-_.!~*'()]|$escaped)";
                                        # reserved | unreserved | escaped
  $urics             =  "(?:(?:[;/?:\@&=+\$,a-zA-Z0-9\\-_.!~*'()]+|"     .
                        "$escaped)*)";
  
  $query             =  $urics;
  $fragment          =  $urics;
  $param             =  "(?:(?:[a-zA-Z0-9\\-_.!~*'():\@&=+\$,]+|$escaped)*)";
  $segment           =  "(?:$param(?:;$param)*)";
  $path_segments     =  "(?:$segment(?:/$segment)*)";
  $ftp_segments      =  "(?:$param(?:/$param)*)";   # NOT from RFC 2396.
  $rel_segment       =  "(?:(?:[a-zA-Z0-9\\-_.!~*'();\@&=+\$,]*|$escaped)+)";
  $abs_path          =  "(?:/$path_segments)";
  $rel_path          =  "(?:$rel_segment(?:$abs_path)?)";
  $path              =  "(?:(?:$abs_path|$rel_path)?)";
  
  $port              =  "(?:$digit*)";
  $IPv4address       =  "(?:$digit+[.]$digit+[.]$digit+[.]$digit+)";
  $toplabel          =  "(?:$alpha"."[-a-zA-Z0-9]*$alphanum|$alpha)";
  $domainlabel       =  "(?:(?:$alphanum"."[-a-zA-Z0-9]*)?$alphanum)";
  $hostname          =  "(?:(?:$domainlabel\[.])*$toplabel\[.]?)";
  $host              =  "(?:$hostname|$IPv4address)";
  $hostport          =  "(?:$host(?::$port)?)";
  
  $userinfo          =  "(?:(?:[a-zA-Z0-9\\-_.!~*'();:&=+\$,]+|$escaped)*)";
  $userinfo_no_colon =  "(?:(?:[a-zA-Z0-9\\-_.!~*'();&=+\$,]+|$escaped)*)";
  $server            =  "(?:(?:$userinfo\@)?$hostport)";
  
  $reg_name          =  "(?:(?:[a-zA-Z0-9\\-_.!~*'()\$,;:\@&=+]*|$escaped)+)";
  $authority         =  "(?:$server|$reg_name)";
  
  $scheme            =  "(?:$alpha"."[a-zA-Z0-9+\\-.]*)";
  
  $net_path          =  "(?://$authority$abs_path?)";
  $uric_no_slash     =  "(?:[a-zA-Z0-9\\-_.!~*'();?:\@&=+\$,]|$escaped)";
  $opaque_part       =  "(?:$uric_no_slash$urics)";
  $hier_part         =  "(?:(?:$net_path|$abs_path)(?:[?]$query)?)";
  
  $relativeURI       =  "(?:(?:$net_path|$abs_path|$rel_path)(?:[?]$query)?";
  $absoluteURI       =  "(?:$scheme:(?:$hier_part|$opaque_part))";
  $URI_reference     =  "(?:(?:$absoluteURI|$relativeURI)?(?:#$fragment)?)";
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC2396 -- Definitions from RFC2396;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC2396 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC2396. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =back
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_RFC2396

$fatpacked{"Regexp/Common/URI/RFC2806.pm"} = <<'REGEXP_COMMON_URI_RFC2806';
  package Regexp::Common::URI::RFC2806;
  
  use Regexp::Common::URI::RFC1035 qw /$domain/;
  use Regexp::Common::URI::RFC2396 qw /$unreserved $escaped $hex/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  use vars qw /@EXPORT @EXPORT_OK %EXPORT_TAGS @ISA/;
  
  use Exporter ();
  @ISA = qw /Exporter/;
  
  
  my %vars;
  
  BEGIN {
      $vars {low}     = [qw /$dtmf_digit $wait_for_dial_tone $one_second_pause
                             $pause_character $visual_separator $phonedigit
                             $escaped_no_dquote $quoted_string $token_char
                             $token_chars/];
      $vars {parts}   = [qw /$future_extension/];
      $vars {connect} = [qw /$provider_hostname $provider_tag $service_provider
                             $private_prefix $local_network_prefix 
                             $global_network_prefix $network_prefix/];
      $vars {phone}   = [qw /$phone_context_ident $phone_context_tag
                             $area_specifier $post_dial $isdn_subaddress
                             $t33_subaddress $local_phone_number
                             $local_phone_number_no_future
                             $base_phone_number $global_phone_number
                             $global_phone_number_no_future $telephone_subscriber
                             $telephone_subscriber_no_future/];
      $vars {fax}     = [qw /$fax_local_phone $fax_local_phone_no_future
                             $fax_global_phone $fax_global_phone_no_future
                             $fax_subscriber $fax_subscriber_no_future/];
      $vars {modem}   = [qw //];
  }
  
  use vars map {@$_} values %vars;
  
  @EXPORT      = ();
  @EXPORT_OK   = map {@$_} values %vars;
  %EXPORT_TAGS = (%vars, ALL => [@EXPORT_OK]);
  
  
  # RFC 2806, URIs for tel, fax & modem.
  $dtmf_digit        =  "(?:[*#ABCD])";
  $wait_for_dial_tone=  "(?:w)";
  $one_second_pause  =  "(?:p)";
  $pause_character   =  "(?:[wp])";   # wait_for_dial_tone | one_second_pause.
  $visual_separator  =  "(?:[\\-.()])";
  $phonedigit        =  "(?:[0-9\\-.()])";  # DIGIT | visual_separator
  $escaped_no_dquote =  "(?:%(?:[01]$hex)|2[013-9A-Fa-f]|[3-9A-Fa-f]$hex)";
  $quoted_string     =  "(?:%22(?:(?:%5C(?:$unreserved|$escaped))|" .
                                "$unreserved+|$escaped_no_dquote)*%22)";
                        # It is unclear wether we can allow only unreserved
                        # characters to unescaped, or can we also use uric
                        # characters that are unescaped? Or pchars?
  $token_char        =  "(?:[!'*\\-.0-9A-Z_a-z~]|" .
                            "%(?:2[13-7ABDEabde]|3[0-9]|4[1-9A-Fa-f]|" .
                                "5[AEFaef]|6[0-9A-Fa-f]|7[0-9ACEace]))";
                        # Only allowing unreserved chars to be unescaped.
  $token_chars       =  "(?:(?:[!'*\\-.0-9A-Z_a-z~]+|"                   .
                              "%(?:2[13-7ABDEabde]|3[0-9]|4[1-9A-Fa-f]|" .
                                  "5[AEFaef]|6[0-9A-Fa-f]|7[0-9ACEace]))*)";
  $future_extension  =  "(?:;$token_chars"                       .
                        "(?:=(?:(?:$token_chars(?:[?]$token_chars)?)|" .
                        "$quoted_string))?)";
  $provider_hostname =   $domain;
  $provider_tag      =  "(?:tsp)";
  $service_provider  =  "(?:;$provider_tag=$provider_hostname)";
  $private_prefix    =  "(?:(?:[!'E-OQ-VX-Z_e-oq-vx-z~]|"                   .
                           "(?:%(?:2[124-7CFcf]|3[AC-Fac-f]|4[05-9A-Fa-f]|" .
                                  "5[1-689A-Fa-f]|6[05-9A-Fa-f]|"           .
                                  "7[1-689A-Ea-e])))"                       .
                           "(?:[!'()*\\-.0-9A-Z_a-z~]+|"                    .
                           "(?:%(?:2[1-9A-Fa-f]|3[AC-Fac-f]|"               .
                              "[4-6][0-9A-Fa-f]|7[0-9A-Ea-e])))*)";
  $local_network_prefix
                     =  "(?:[0-9\\-.()*#ABCDwp]+)";
  $global_network_prefix
                     =  "(?:[+][0-9\\-.()]+)";
  $network_prefix    =  "(?:$global_network_prefix|$local_network_prefix)";
  $phone_context_ident
                     =  "(?:$network_prefix|$private_prefix)";
  $phone_context_tag =  "(?:phone-context)";
  $area_specifier    =  "(?:;$phone_context_tag=$phone_context_ident)";
  $post_dial         =  "(?:;postd=[0-9\\-.()*#ABCDwp]+)";
  $isdn_subaddress   =  "(?:;isub=[0-9\\-.()]+)";
  $t33_subaddress    =  "(?:;tsub=[0-9\\-.()]+)";
  
  $local_phone_number=  "(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?"      .
                           "$post_dial?$area_specifier"                 .
                           "(?:$area_specifier|$service_provider|"      .
                              "$future_extension)*)";
  $local_phone_number_no_future
                     =  "(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?"      .
                           "$post_dial?$area_specifier"                 .
                           "(?:$area_specifier|$service_provider)*)";
  $fax_local_phone   =  "(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?"      .
                           "$t33_subaddress?$post_dial?$area_specifier" .
                           "(?:$area_specifier|$service_provider|"      .
                              "$future_extension)*)";
  $fax_local_phone_no_future
                     =  "(?:[0-9\\-.()*#ABCDwp]+$isdn_subaddress?"      .
                           "$t33_subaddress?$post_dial?$area_specifier" .
                           "(?:$area_specifier|$service_provider)*)";
  $base_phone_number =  "(?:[0-9\\-.()]+)";
  $global_phone_number
                     =  "(?:[+]$base_phone_number$isdn_subaddress?"     .
                                                "$post_dial?"           .
                           "(?:$area_specifier|$service_provider|"      .
                              "$future_extension)*)";
  $global_phone_number_no_future
                     =  "(?:[+]$base_phone_number$isdn_subaddress?"     .
                                                "$post_dial?"           .
                           "(?:$area_specifier|$service_provider)*)";
  $fax_global_phone  =  "(?:[+]$base_phone_number$isdn_subaddress?"     .
                                "$t33_subaddress?$post_dial?"           .
                           "(?:$area_specifier|$service_provider|"      .
                              "$future_extension)*)";
  $fax_global_phone_no_future
                     =  "(?:[+]$base_phone_number$isdn_subaddress?"     .
                                "$t33_subaddress?$post_dial?"           .
                           "(?:$area_specifier|$service_provider)*)";
  $telephone_subscriber
                     =  "(?:$global_phone_number|$local_phone_number)";
  $telephone_subscriber_no_future
                     =  "(?:$global_phone_number_no_future|" .
                           "$local_phone_number_no_future)";
  $fax_subscriber    =  "(?:$fax_global_phone|$fax_local_phone)";
  $fax_subscriber_no_future
                     =  "(?:$fax_global_phone_no_future|"    .
                           "$fax_local_phone_no_future)";
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::RFC2806 -- Definitions from RFC2806;
  
  =head1 SYNOPSIS
  
      use Regexp::Common::URI::RFC2806 qw /:ALL/;
  
  =head1 DESCRIPTION
  
  This package exports definitions from RFC2806. It's intended
  usage is for Regexp::Common::URI submodules only. Its interface
  might change without notice.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 2616]>
  
  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
  Leach, P. and Berners-Lee, Tim: I<Hypertext Transfer Protocol -- HTTP/1.1>.
  June 1999.
  
  =back
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_RFC2806

$fatpacked{"Regexp/Common/URI/fax.pm"} = <<'REGEXP_COMMON_URI_FAX';
  package Regexp::Common::URI::fax;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC2806 qw /$fax_subscriber 
                                       $fax_subscriber_no_future/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $fax_scheme  = 'fax';
  my $fax_uri     = "(?k:(?k:$fax_scheme):(?k:$fax_subscriber))";
  my $fax_uri_nf  = "(?k:(?k:$fax_scheme):(?k:$fax_subscriber_no_future))";
  
  register_uri $fax_scheme => $fax_uri;
  
  pattern name    => [qw (URI fax)],
          create  => $fax_uri
          ;
  
  pattern name    => [qw (URI fax nofuture)],
          create  => $fax_uri_nf
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::fax -- Returns a pattern for fax URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{fax}/       and  print "Contains a fax URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{fax}
  
  Returns a pattern that matches I<fax> URIs, as defined by RFC 2806.
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The phone number, including any possible add-ons like ISDN subaddress,
  a post dial part, area specifier, service provider, etc.
  
  =back
  
  =head2 C<$RE{URI}{fax}{nofuture}>
  
  As above (including what's returned by C<{-keep}>), with the exception
  that I<future extensions> are not allowed. Without allowing 
  those I<future extensions>, it becomes much easier to check a URI if
  the correct syntax for post dial, service provider, phone context,
  etc has been used - otherwise the regex could always classify them
  as a I<future extension>.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1035]>
  
  Mockapetris, P.: I<DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION>.
  November 1987.
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =item B<[RFC 2806]>
  
  Vaha-Sipila, A.: I<URLs for Telephone Calls>. April 2000.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_FAX

$fatpacked{"Regexp/Common/URI/file.pm"} = <<'REGEXP_COMMON_URI_FILE';
  package Regexp::Common::URI::file;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$host $fpath/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $scheme = 'file';
  my $uri    = "(?k:(?k:$scheme)://(?k:(?k:(?:$host|localhost)?)" .
               "(?k:/(?k:$fpath))))";
  
  register_uri $scheme => $uri;
  
  pattern name    => [qw (URI file)],
          create  => $uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::file -- Returns a pattern for file URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{file}/       and  print "Contains a file URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{file}
  
  Returns a pattern that matches I<file> URIs, as defined by RFC 1738.
  File URIs have the form:
  
      "file:" "//" [ host | "localhost" ] "/" fpath
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The part of the URI following "file://".
  
  =item $4
  
  The hostname.
  
  =item $5
  
  The path name, including the leading slash.
  
  =item $6
  
  The path name, without the leading slash.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_FILE

$fatpacked{"Regexp/Common/URI/ftp.pm"} = <<'REGEXP_COMMON_URI_FTP';
  package Regexp::Common::URI::ftp;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC2396 qw /$host $port $ftp_segments $userinfo
                                       $userinfo_no_colon/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $ftp_uri = "(?k:(?k:ftp)://(?:(?k:$userinfo)(?k:)\@)?(?k:$host)" .
                "(?::(?k:$port))?(?k:/(?k:(?k:$ftp_segments)"         .
                "(?:;type=(?k:[AIai]))?))?)";
  
  my $ftp_uri_password =
                "(?k:(?k:ftp)://(?:(?k:$userinfo_no_colon)"           .
                "(?::(?k:$userinfo_no_colon))?\@)?(?k:$host)"         .
                "(?::(?k:$port))?(?k:/(?k:(?k:$ftp_segments)"         .
                "(?:;type=(?k:[AIai]))?))?)";
  
  register_uri FTP => $ftp_uri;
  
  pattern name    => [qw (URI FTP), "-type=[AIai]", "-password="],
          create  => sub {
              my $uri    =  exists $_ [1] -> {-password} &&
                          !defined $_ [1] -> {-password} ? $ftp_uri_password
                                                         : $ftp_uri;
              my $type   =  $_ [1] -> {-type};
              $uri       =~ s/\[AIai\]/$type/;
              $uri;
          }
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::ftp -- Returns a pattern for FTP URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{FTP}/       and  print "Contains an FTP URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{FTP}{-type}{-password};
  
  Returns a regex for FTP URIs. Note: FTP URIs are not formally defined.
  RFC 1738 defines FTP URLs, but parts of that RFC have been obsoleted
  by RFC 2396. However, the differences between RFC 1738 and RFC 2396 
  are such that they aren't applicable straightforwardly to FTP URIs.
  
  There are two main problems:
  
  =over 4
  
  =item Passwords.
  
  RFC 1738 allowed an optional username and an optional password (separated
  by a colon) in the FTP URL. Hence, colons were not allowed in either the
  username or the password. RFC 2396 strongly recommends passwords should
  not be used in URIs. It does allow for I<userinfo> instead. This userinfo
  part may contain colons, and hence contain more than one colon. The regexp
  returned follows the RFC 2396 specification, unless the I<{-password}>
  option is given; then the regex allows for an optional username and
  password, separated by a colon.
  
  =item The ;type specifier.
  
  RFC 1738 does not allow semi-colons in FTP path names, because a semi-colon
  is a reserved character for FTP URIs. The semi-colon is used to separate
  the path from the option I<type> specifier. However, in RFC 2396, paths
  consist of slash separated segments, and each segment is a semi-colon 
  separated group of parameters. Straigthforward application of RFC 2396
  would mean that a trailing I<type> specifier couldn't be distinguished
  from the last segment of the path having a two parameters, the last one
  starting with I<type=>. Therefore we have opted to disallow a semi-colon
  in the path part of an FTP URI.
  
  Furthermore, RFC 1738 allows three values for the type specifier, I<A>,
  I<I> and I<D> (either upper case or lower case). However, the internet
  draft about FTP URIs B<[DRAFT-FTP-URL]> (which expired in May 1997) notes
  the lack of consistent implementation of the I<D> parameter and drops I<D>
  from the set of possible values. We follow this practise; however, RFC 1738
  behaviour can be archieved by using the I<-type => "[ADIadi]"> parameter.
  
  =back
  
  FTP URIs have the following syntax:
  
      "ftp:" "//" [ userinfo "@" ] host [ ":" port ]
                  [ "/" path [ ";type=" value ]]
  
  When using I<{-password}>, we have the syntax:
  
      "ftp:" "//" [ user [ ":" password ] "@" ] host [ ":" port ]
                  [ "/" path [ ";type=" value ]]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The userinfo, or if I<{-password}> is used, the username.
  
  =item $4
  
  If I<{-password}> is used, the password, else C<undef>.
  
  =item $5
  
  The hostname or IP address.
  
  =item $6
  
  The port number.
  
  =item $7
  
  The full path and type specification, including the leading slash.
  
  =item $8
  
  The full path and type specification, without the leading slash.
  
  =item $9
  
  The full path, without the type specification nor the leading slash.
  
  =item $10
  
  The value of the type specification.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[DRAFT-URL-FTP]>
  
  Casey, James: I<A FTP URL Format>. November 1996.
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_FTP

$fatpacked{"Regexp/Common/URI/gopher.pm"} = <<'REGEXP_COMMON_URI_GOPHER';
  package Regexp::Common::URI::gopher;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$host $port $uchars/;
  use Regexp::Common::URI::RFC1808 qw /$pchars $pchar_range/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $pchars_notab      = "(?:(?:[$pchar_range]+|" . 
                          "%(?:[1-9a-fA-F][0-9a-fA-F]|0[0-8a-fA-F]))*)";
  
  my $gopherplus_string = $pchars;
  my $search            = $pchars;
  my $search_notab      = $pchars_notab;
  my $selector          = $pchars;
  my $selector_notab    = $pchars_notab;
  my $gopher_type       = "(?:[0-9+IgT])";
  
  my $scheme     = "gopher";
  my $uri        = "(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?" .
                   "/(?k:(?k:$gopher_type)(?k:$selector)))";
  my $uri_notab  = "(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?"              .
                   "/(?k:(?k:$gopher_type)(?k:$selector_notab)"                 .
                   "(?:%09(?k:$search_notab)(?:%09(?k:$gopherplus_string))?)?))";
  
  register_uri $scheme => $uri;
  
  pattern name    => [qw (URI gopher -notab=)],
          create  => sub { exists $_ [1] {-notab} &&
                         !defined $_ [1] {-notab} ? $uri_notab : $uri},
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::gopher -- Returns a pattern for gopher URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{gopher}/       and  print "Contains a gopher URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{gopher}{-notab}
  
  Gopher URIs are poorly defined. Originally, RFC 1738 defined gopher URIs,
  but they were later redefined in an internet draft. One that was expired
  in June 1997.
  
  The internet draft for gopher URIs defines them as follows:
  
      "gopher:" "//" host [ ":" port ] "/" gopher-type selector
                          [ "%09" search [ "%09" gopherplus_string ]]
  
  Unfortunally, a I<selector> is defined in such a way that characters
  may be escaped using the URI escape mechanism. This includes tabs,
  which escaped are C<%09>. Hence, the syntax cannot distinguish between
  a URI that has both a I<selector> and a I<search> part, and an URI
  where the I<selector> includes an escaped tab. (The text of the draft
  forbids tabs to be present in the I<selector> though).
  
  C<$RE{URI}{gopher}> follows the defined syntax. To disallow escaped
  tabs in the I<selector> and I<search> parts, use C<$RE{URI}{gopher}{-notab}>.
  
  There are other differences between the text and the given syntax.
  According to the text, selector strings cannot have tabs, linefeeds
  or carriage returns in them. The text also allows the entire I<gopher-path>,
  (the part after the slash following the hostport) to be empty; if this
  is empty the slash may be omitted as well. However, this isn't reflected
  in the syntax.
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The entire URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The host (name or address).
  
  =item $4
  
  The port (if any).
  
  =item $5
  
  The "gopher-path", the part after the / following the host and port.
  
  =item $6
  
  The gopher-type.
  
  =item $7
  
  The selector. (When no C<{-notab}> is used, this includes the search
  and gopherplus_string, including the separating escaped tabs).
  
  =item $8
  
  The search, if given. (Only when C<{-notab}> is given).
  
  =item $9
  
  The gopherplus_string, if given. (Only when C<{-notab}> is given).
  
  =back
  
  head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =item B<[RFC 1808]>
  
  Fielding, R.: I<Relative Uniform Resource Locators (URL)>. June 1995.
  
  =item B<[GOPHER URL]>
  
  Krishnan, Murali R., Casey, James: "A Gopher URL Format". Expired
  Internet draft I<draft-murali-url-gopher>. December 1996.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_GOPHER

$fatpacked{"Regexp/Common/URI/http.pm"} = <<'REGEXP_COMMON_URI_HTTP';
  package Regexp::Common::URI::http;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC2396 qw /$host $port $path_segments $query/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $http_uri = "(?k:(?k:http)://(?k:$host)(?::(?k:$port))?"           .
                 "(?k:/(?k:(?k:$path_segments)(?:[?](?k:$query))?))?)";
  
  register_uri HTTP => $http_uri;
  
  pattern name    => [qw (URI HTTP), "-scheme=http"],
          create  => sub {
              my $scheme =  $_ [1] -> {-scheme};
              my $uri    =  $http_uri;
                 $uri    =~ s/http/$scheme/;
              $uri;
          }
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::http -- Returns a pattern for HTTP URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{HTTP}/       and  print "Contains an HTTP URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{HTTP}{-scheme}
  
  Provides a regex for an HTTP URI as defined by RFC 2396 (generic syntax)
  and RFC 2616 (HTTP).
  
  If C<< -scheme => I<P> >> is specified the pattern I<P> is used as the scheme.
  By default I<P> is C<qr/http/>. C<https> and C<https?> are reasonable
  alternatives.
  
  The syntax for an HTTP URI is:
  
      "http:" "//" host [ ":" port ] [ "/" path [ "?" query ]]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The entire URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The host (name or address).
  
  =item $4
  
  The port (if any).
  
  =item $5
  
  The absolute path, including the query and leading slash.
  
  =item $6
  
  The absolute path, including the query, without the leading slash.
  
  =item $7
  
  The absolute path, without the query or leading slash.
  
  =item $8
  
  The query, without the question mark.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =item B<[RFC 2616]>
  
  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., 
  Leach, P. and Berners-Lee, Tim: I<Hypertext Transfer Protocol -- HTTP/1.1>.
  June 1999.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_HTTP

$fatpacked{"Regexp/Common/URI/news.pm"} = <<'REGEXP_COMMON_URI_NEWS';
  package Regexp::Common::URI::news;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$grouppart $group $article
                                       $host $port $digits/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $news_scheme = 'news';
  my $news_uri    = "(?k:(?k:$news_scheme):(?k:$grouppart))";
  
  my $nntp_scheme = 'nntp';
  my $nntp_uri    = "(?k:(?k:$nntp_scheme)://(?k:(?k:(?k:$host)(?::(?k:$port))?)" 
                  . "/(?k:$group)(?:/(?k:$digits))?))";
  
  register_uri $news_scheme => $news_uri;
  register_uri $nntp_scheme => $nntp_uri;
  
  pattern name    => [qw (URI news)],
          create  => $news_uri,
          ;
  
  pattern name    => [qw (URI NNTP)],
          create  => $nntp_uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::news -- Returns a pattern for file URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{news}/       and  print "Contains a news URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{news}
  
  Returns a pattern that matches I<news> URIs, as defined by RFC 1738.
  News URIs have the form:
  
      "news:" ( "*" | group | article "@" host )
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The part of the URI following "news://".
  
  =back
  
  =head2 $RE{URI}{NNTP}
  
  Returns a pattern that matches I<NNTP> URIs, as defined by RFC 1738.
  NNTP URIs have the form:
  
      "nntp://" host [ ":" port ] "/" group [ "/" digits ]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The part of the URI following "nntp://".
  
  =item $4
  
  The host and port, separated by a colon. If no port was given, just
  the host.
  
  =item $5
  
  The host.
  
  =item $6
  
  The port, if given.
  
  =item $7
  
  The group.
  
  =item $8
  
  The digits, if given.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_NEWS

$fatpacked{"Regexp/Common/URI/pop.pm"} = <<'REGEXP_COMMON_URI_POP';
  package Regexp::Common::URI::pop;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$host $port/;
  use Regexp::Common::URI::RFC2384 qw /$enc_user $enc_auth_type/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $scheme = "pop";
  my $uri    = "(?k:(?k:$scheme)://(?:(?k:$enc_user)"     .  
               "(?:;AUTH=(?k:[*]|$enc_auth_type))?\@)?"   .
               "(?k:$host)(?::(?k:$port))?)";
  
  register_uri $scheme => $uri;
  
  pattern name    => [qw (URI POP)],
          create  => $uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::pop -- Returns a pattern for POP URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{POP}/       and  print "Contains a POP URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{POP}
  
  Returns a pattern that matches I<POP> URIs, as defined by RFC 2384.
  POP URIs have the form:
  
      "pop:" "//" [ user [ ";AUTH" ( "*" | auth_type ) ] "@" ]
                    host [ ":" port ]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The I<scheme>.
  
  =item $3
  
  The I<user>, if given.
  
  =item $4
  
  The I<authentication type>, if given (could be a I<*>).
  
  =item $5
  
  The I<host>.
  
  =item $6
  
  The I<port>, if given.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 2384]>
  
  Gellens, R.: I<POP URL Scheme>. August 1998.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Abigail. (I<regexp-common@abigail.be>).
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_POP

$fatpacked{"Regexp/Common/URI/prospero.pm"} = <<'REGEXP_COMMON_URI_PROSPERO';
  package Regexp::Common::URI::prospero;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$host $port $ppath $fieldname $fieldvalue
                                       $fieldspec/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $scheme = 'prospero';
  my $uri    = "(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?" .
               "/(?k:$ppath)(?k:$fieldspec*))";
  
  register_uri $scheme => $uri;
  
  pattern name    => [qw (URI prospero)],
          create  => $uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::prospero -- Returns a pattern for prospero URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{prospero}/ and print "Contains a prospero URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{prospero}
  
  Returns a pattern that matches I<prospero> URIs, as defined by RFC 1738.
  prospero URIs have the form:
  
      "prospero:" "//" host [ ":" port ] "/" path [ fieldspec ] *
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The I<scheme>.
  
  =item $3
  
  The I<hostname>.
  
  =item $4
  
  The I<port>, if given.
  
  =item $5
  
  The propero path.
  
  =item $6
  
  The field specifications, if given. There can be more field specifications;
  they will all be returned in C<$6>.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Abigail. (I<regexp-common@abigail.be>).
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_PROSPERO

$fatpacked{"Regexp/Common/URI/tel.pm"} = <<'REGEXP_COMMON_URI_TEL';
  package Regexp::Common::URI::tel;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC2806 qw /$telephone_subscriber 
                                       $telephone_subscriber_no_future/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $tel_scheme  = 'tel';
  my $tel_uri     = "(?k:(?k:$tel_scheme):(?k:$telephone_subscriber))";
  my $tel_uri_nf  = "(?k:(?k:$tel_scheme):(?k:$telephone_subscriber_no_future))";
  
  register_uri $tel_scheme => $tel_uri;
  
  pattern name    => [qw (URI tel)],
          create  => $tel_uri
          ;
  
  pattern name    => [qw (URI tel nofuture)],
          create  => $tel_uri_nf
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::tel -- Returns a pattern for telephone URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{tel}/       and  print "Contains a telephone URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{tel}
  
  Returns a pattern that matches I<tel> URIs, as defined by RFC 2806.
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The phone number, including any possible add-ons like ISDN subaddress,
  a post dial part, area specifier, service provider, etc.
  
  =back
  
  =head2 C<$RE{URI}{tel}{nofuture}>
  
  As above (including what's returned by C<{-keep}>), with the exception
  that I<future extensions> are not allowed. Without allowing 
  those I<future extensions>, it becomes much easier to check a URI if
  the correct syntax for post dial, service provider, phone context,
  etc has been used - otherwise the regex could always classify them
  as a I<future extension>.
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1035]>
  
  Mockapetris, P.: I<DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION>.
  November 1987.
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =item B<[RFC 2806]>
  
  Vaha-Sipila, A.: I<URLs for Telephone Calls>. April 2000.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_TEL

$fatpacked{"Regexp/Common/URI/telnet.pm"} = <<'REGEXP_COMMON_URI_TELNET';
  package Regexp::Common::URI::telnet;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$user $password $host $port/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $telnet_uri = "(?k:(?k:telnet)://(?:(?k:(?k:$user)(?::(?k:$password))?)\@)?" 
                 . "(?k:(?k:$host)(?::(?k:$port))?)(?k:/)?)";
  
  register_uri telnet => $telnet_uri;
  
  pattern name    => [qw (URI telnet)],
          create  => $telnet_uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::telnet -- Returns a pattern for telnet URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{telnet}/       and  print "Contains a telnet URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{telnet}
  
  Returns a pattern that matches I<telnet> URIs, as defined by RFC 1738.
  Telnet URIs have the form:
  
      "telnet:" "//" [ user [ ":" password ] "@" ] host [ ":" port ] [ "/" ]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The username:password combo, or just the username if there is no password.
  
  =item $4
  
  The username, if given.
  
  =item $5
  
  The password, if given.
  
  =item $6
  
  The host:port combo, or just the host if there's no port.
  
  =item $7
  
  The host.
  
  =item $8
  
  The port, if given.
  
  =item $9
  
  The trailing slash, if any.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_TELNET

$fatpacked{"Regexp/Common/URI/tv.pm"} = <<'REGEXP_COMMON_URI_TV';
  # TV URLs. 
  # Internet draft: draft-zigmond-tv-url-03.txt
  
  package Regexp::Common::URI::tv;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC2396 qw /$hostname/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $tv_scheme = 'tv';
  my $tv_url    = "(?k:(?k:$tv_scheme):(?k:$hostname)?)";
  
  register_uri $tv_scheme => $tv_url;
  
  pattern name    => [qw (URI tv)],
          create  => $tv_url,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::tv -- Returns a pattern for tv URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{tv}/       and  print "Contains a tv URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 C<$RE{URI}{tv}>
  
  Returns a pattern that recognizes TV uris as per an Internet draft
  [DRAFT-URI-TV].
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The entire URI.
  
  =item $2
  
  The scheme.
  
  =item $3
  
  The host.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[DRAFT-URI-TV]>
  
  Zigmond, D. and Vickers, M: I<Uniform Resource Identifiers for
  Television Broadcasts>. December 2000.
  
  =item B<[RFC 2396]>
  
  Berners-Lee, Tim, Fielding, R., and Masinter, L.: I<Uniform Resource
  Identifiers (URI): Generic Syntax>. August 1998.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_TV

$fatpacked{"Regexp/Common/URI/wais.pm"} = <<'REGEXP_COMMON_URI_WAIS';
  package Regexp::Common::URI::wais;
  
  use Regexp::Common               qw /pattern clean no_defaults/;
  use Regexp::Common::URI          qw /register_uri/;
  use Regexp::Common::URI::RFC1738 qw /$host $port
                                       $search $database $wtype $wpath/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my $scheme = 'wais';
  my $uri    = "(?k:(?k:$scheme)://(?k:$host)(?::(?k:$port))?/(?k:(?k:$database)" 
             . "(?k:[?](?k:$search)|/(?k:$wtype)/(?k:$wpath))?))";
  
  register_uri $scheme => $uri;
  
  pattern name    => [qw (URI WAIS)],
          create  => $uri,
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::URI::wais -- Returns a pattern for WAIS URIs.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /URI/;
  
      while (<>) {
          /$RE{URI}{WAIS}/       and  print "Contains a WAIS URI.\n";
      }
  
  =head1 DESCRIPTION
  
  =head2 $RE{URI}{WAIS}
  
  Returns a pattern that matches I<WAIS> URIs, as defined by RFC 1738.
  WAIS URIs have the form:
  
      "wais:" "//" host [ ":" port ] "/" database
                        [ ( "?" search ) | ( "/" wtype "/" wpath ) ]
  
  Under C<{-keep}>, the following are returned:
  
  =over 4
  
  =item $1
  
  The complete URI.
  
  =item $2
  
  The I<scheme>.
  
  =item $3
  
  The I<hostname>.
  
  =item $4
  
  The I<port>, if given.
  
  =item $5
  
  The I<database>, followed by I<search> or I<wtype/wpath>, if given.
  
  =item $6
  
  The I<database>.
  
  =item $7
  
  The part following the I<database> if given, including the question mark 
  or slash.
  
  =item $8
  
  The I<search> part, if given.
  
  =item $9
  
  The I<wtype>, if given.
  
  =item $10
  
  The I<wpath>, if given.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[RFC 1738]>
  
  Berners-Lee, Tim, Masinter, L., McCahill, M.: I<Uniform Resource
  Locators (URL)>. December 1994.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common::URI> for other supported URIs.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_URI_WAIS

$fatpacked{"Regexp/Common/_support.pm"} = <<'REGEXP_COMMON__SUPPORT';
  package Regexp::Common::_support;
  
  BEGIN {
      # This makes sure 'use warnings' doesn't bomb out on 5.005_*;
      # warnings won't be enabled on those old versions though.
      if ($] < 5.006 && !exists $INC {"warnings.pm"}) {
          $INC {"warnings.pm"} = 1;
          no strict 'refs';
          *{"warnings::unimport"} = sub {0};
      }
  }
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  #
  # Returns true/false, depending whether the given the argument
  # satisfies the LUHN checksum.
  # See http://www.webopedia.com/TERM/L/Luhn_formula.html.
  #
  # Note that this function is intended to be called from regular
  # expression, so it should NOT use a regular expression in any way.
  #
  sub luhn {
      my $arg  = shift;
      my $even = 0;
      my $sum  = 0;
      while (length $arg) {
          my $num = chop $arg;
          return if $num lt '0' || $num gt '9';
          if ($even && (($num *= 2) > 9)) {$num = 1 + ($num % 10)}
          $even = 1 - $even;
          $sum += $num;
      }
      !($sum % 10)
  }
  
  sub import {
      my $pack   = shift;
      my $caller = caller;
      no strict 'refs';
      *{$caller . "::" . $_} = \&{$pack . "::" . $_} for @_;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::support -- Support functions for Regexp::Common.
  
  =head1 SYNOPSIS
  
      use Regexp::Common::_support qw /luhn/;
  
      luhn ($number)    # Returns true/false.
  
  
  =head1 DESCRIPTION
  
  This module contains some subroutines to be used by other C<Regexp::Common>
  modules. It's not intended to be used directly. Subroutines from the 
  module may disappear without any notice, or their meaning or interface
  may change without notice.
  
  =over 4
  
  =item luhn
  
  This subroutine returns true if its argument passes the luhn checksum test.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://www.webopedia.com/TERM/L/Luhn_formula.html>.
  
  =head1 AUTHOR
  
  Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON__SUPPORT

$fatpacked{"Regexp/Common/balanced.pm"} = <<'REGEXP_COMMON_BALANCED';
  package Regexp::Common::balanced; {
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  my %closer = ( '{'=>'}', '('=>')', '['=>']', '<'=>'>' );
  my $count = -1;
  my %cache;
  
  sub nested {
      my ($start, $finish) = @_;
  
      return $Regexp::Common::balanced [$cache {$start} {$finish}]
              if exists $cache {$start} {$finish};
  
      $count ++;
      my $r = '(??{$Regexp::Common::balanced ['. $count . ']})';
  
      my @starts   = map {s/\\(.)/$1/g; $_} grep {length}
                          $start  =~ /([^|\\]+|\\.)+/gs;
      my @finishes = map {s/\\(.)/$1/g; $_} grep {length}
                          $finish =~ /([^|\\]+|\\.)+/gs;
  
      push @finishes => ($finishes [-1]) x (@starts - @finishes);
  
      my @re;
      local $" = "|";
      foreach my $begin (@starts) {
          my $end = shift @finishes;
  
          my $qb  = quotemeta $begin;
          my $qe  = quotemeta $end;
          my $fb  = quotemeta substr $begin => 0, 1;
          my $fe  = quotemeta substr $end   => 0, 1;
  
          my $tb  = quotemeta substr $begin => 1;
          my $te  = quotemeta substr $end   => 1;
  
          use re 'eval';
  
          my $add;
          if ($fb eq $fe) {
              push @re =>
                     qr /(?:$qb(?:(?>[^$fb]+)|$fb(?!$tb)(?!$te)|$r)*$qe)/;
          }
          else {
              my   @clauses =  "(?>[^$fb$fe]+)";
              push @clauses => "$fb(?!$tb)" if length $tb;
              push @clauses => "$fe(?!$te)" if length $te;
              push @clauses =>  $r;
              push @re      =>  qr /(?:$qb(?:@clauses)*$qe)/;
          }
      }
  
      $cache {$start} {$finish} = $count;
      $Regexp::Common::balanced [$count] = qr/@re/;
  }
  
  
  pattern name    => [qw /balanced -parens=() -begin= -end=/],
          create  => sub {
              my $flag = $_[1];
              unless (defined $flag -> {-begin} && length $flag -> {-begin} &&
                      defined $flag -> {-end}   && length $flag -> {-end}) {
                  my @open  = grep {index ($flag->{-parens}, $_) >= 0}
                               ('[','(','{','<');
                  my @close = map {$closer {$_}} @open;
                  $flag -> {-begin} = join "|" => @open;
                  $flag -> {-end}   = join "|" => @close;
              }
              my $pat = nested @$flag {qw /-begin -end/};
              return exists $flag -> {-keep} ? qr /($pat)/ : $pat;
          },
          version => 5.006,
          ;
  
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::balanced -- provide regexes for strings with balanced
  parenthesized delimiters or arbitrary delimiters.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /balanced/;
  
      while (<>) {
          /$RE{balanced}{-parens=>'()'}/
                                     and print q{balanced parentheses\n};
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{balanced}{-parens}>
  
  Returns a pattern that matches a string that starts with the nominated
  opening parenthesis or bracket, contains characters and properly nested
  parenthesized subsequences, and ends in the matching parenthesis.
  
  More than one type of parenthesis can be specified:
  
          $RE{balanced}{-parens=>'(){}'}
  
  in which case all specified parenthesis types must be correctly balanced within
  the string.
  
  If we are using C{-keep} (See L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire expression
  
  =back
  
  =head2 C<< $RE{balanced}{-begin => "begin"}{-end => "end"} >>
  
  Returns a pattern that matches a string that is properly balanced
  using the I<begin> and I<end> strings as start and end delimiters.
  Multiple sets of begin and end strings can be given by separating
  them by C<|>s (which can be escaped with a backslash).
  
      qr/$RE{balanced}{-begin => "do|if|case"}{-end => "done|fi|esac"}/
  
  will match properly balanced strings that either start with I<do> and
  end with I<done>, start with I<if> and end with I<fi>, or start with
  I<case> and end with I<esac>.
  
  If I<-end> contains less cases than I<-begin>, the last case of I<-end>
  is repeated. If it contains more cases than I<-begin>, the extra cases
  are ignored. If either of I<-begin> or I<-end> isn't given, or is empty,
  I<< -begin => '(' >> and I<< -end => ')' >> are assumed.
  
  If we are using C{-keep} (See L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire expression
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_BALANCED

$fatpacked{"Regexp/Common/comment.pm"} = <<'REGEXP_COMMON_COMMENT';
  package Regexp::Common::comment;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  my @generic = (
      {languages => [qw /ABC Forth/],
       to_eol    => ['\\\\']},   # This is for just a *single* backslash.
  
      {languages => [qw /Ada Alan Eiffel lua/],
       to_eol    => ['--']},
  
      {languages => [qw /Advisor/],
       to_eol    => ['#|//']},
  
      {languages => [qw /Advsys CQL Lisp LOGO M MUMPS REBOL Scheme
                         SMITH zonefile/],
       to_eol    => [';']},
  
      {languages => ['Algol 60'],
       from_to   => [[qw /comment ;/]]},
  
      {languages => [qw {ALPACA B C C-- LPC PL/I}],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw /awk fvwm2 Icon m4 mutt Perl Python QML
                         R Ruby shell Tcl/],
       to_eol    => ['#']},
  
      {languages => [[BASIC => 'mvEnterprise']],
       to_eol    => ['[*!]|REM']},
  
      {languages => [qw /Befunge-98 Funge-98 Shelta/],
       id        => [';']},
  
      {languages => ['beta-Juliet', 'Crystal Report', 'Portia', 'Ubercode'],
       to_eol    => ['//']},
  
      {languages => ['BML'],
       from_to   => [['<?_c', '_c?>']],
      },
  
      {languages => [qw /C++/, 'C#', qw /Cg ECMAScript FPL Java JavaScript/],
       to_eol    => ['//'],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw /CLU LaTeX slrn TeX/],
       to_eol    => ['%']},
  
      {languages => [qw /False/],
       from_to   => [[qw !{ }!]]},
  
      {languages => [qw /Fortran/],
       to_eol    => ['!']},
  
      {languages => [qw /Haifu/],
       id        => [',']},
  
      {languages => [qw /ILLGOL/],
       to_eol    => ['NB']},
  
      {languages => [qw /INTERCAL/],
       to_eol    => [q{(?:(?:PLEASE(?:\s+DO)?|DO)\s+)?(?:NOT|N'T)}]},
  
      {languages => [qw /J/],
       to_eol    => ['NB[.]']},
  
      {languages => [qw /Nickle/],
       to_eol    => ['#'],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw /Oberon/],
       from_to   => [[qw /(* *)/]]},
       
      {languages => [[qw /Pascal Delphi/], [qw /Pascal Free/], [qw /Pascal GPC/]],
       to_eol    => ['//'],
       from_to   => [[qw !{ }!], [qw !(* *)!]]},
  
      {languages => [[qw /Pascal Workshop/]],
       id        => [qw /"/],
       from_to   => [[qw !{ }!], [qw !(* *)!], [qw !/* */!]]},
  
      {languages => [qw /PEARL/],
       to_eol    => ['!'],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw /PHP/],
       to_eol    => ['#', '//'],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw !PL/B!],
       to_eol    => ['[.;]']},
  
      {languages => [qw !PL/SQL!],
       to_eol    => ['--'],
       from_to   => [[qw {/* */}]]},
  
      {languages => [qw /Q-BAL/],
       to_eol    => ['`']},
  
      {languages => [qw /Smalltalk/],
       id        => ['"']},
  
      {languages => [qw /SQL/],
       to_eol    => ['-{2,}']},
  
      {languages => [qw /troff/],
       to_eol    => ['\\\"']},
  
      {languages => [qw /vi/],
       to_eol    => ['"']},
  
      {languages => [qw /*W/],
       from_to   => [[qw {|| !!}]]},
  
      {languages => [qw /ZZT-OOP/],
       to_eol    => ["'"]},
  );
  
  my @plain_or_nested = (
     [Caml         =>  undef,       "(*"  => "*)"],
     [Dylan        =>  "//",        "/*"  => "*/"],
     [Haskell      =>  "-{2,}",     "{-"  => "-}"],
     [Hugo         =>  "!(?!\\\\)", "!\\" => "\\!"],
     [SLIDE        =>  "#",         "(*"  => "*)"],
    ['Modula-2'    =>  undef,       "(*"  => "*)"],
    ['Modula-3'    =>  undef,       "(*"  => "*)"],
  );
  
  #
  # Helper subs.
  #
  
  sub combine      {
      local $_ = join "|", @_;
      if (@_ > 1) {
          s/\(\?k:/(?:/g;
          $_ = "(?k:$_)";
      }
      $_
  }
  
  sub to_eol  ($)  {"(?k:(?k:$_[0])(?k:[^\\n]*)(?k:\\n))"}
  sub id      ($)  {"(?k:(?k:$_[0])(?k:[^$_[0]]*)(?k:$_[0]))"}  # One char only!
  sub from_to      {
      my ($begin, $end) = @_;
  
      my $qb  = quotemeta $begin;
      my $qe  = quotemeta $end;
      my $fe  = quotemeta substr $end   => 0, 1;
      my $te  = quotemeta substr $end   => 1;
  
      "(?k:(?k:$qb)(?k:(?:[^$fe]+|$fe(?!$te))*)(?k:$qe))";
  }
  
  
  my $count = 0;
  sub nested {
      my ($begin, $end) = @_;
  
      $count ++;
      my $r = '(??{$Regexp::Common::comment ['. $count . ']})';
  
      my $qb  = quotemeta $begin;
      my $qe  = quotemeta $end;
      my $fb  = quotemeta substr $begin => 0, 1;
      my $fe  = quotemeta substr $end   => 0, 1;
  
      my $tb  = quotemeta substr $begin => 1;
      my $te  = quotemeta substr $end   => 1;
  
      use re 'eval';
  
      my $re;
      if ($fb eq $fe) {
          $re = qr /(?:$qb(?:(?>[^$fb]+)|$fb(?!$tb)(?!$te)|$r)*$qe)/;
      }
      else {
          local $"      =  "|";
          my   @clauses =  "(?>[^$fb$fe]+)";
          push @clauses => "$fb(?!$tb)" if length $tb;
          push @clauses => "$fe(?!$te)" if length $te;
          push @clauses =>  $r;
          $re           =   qr /(?:$qb(?:@clauses)*$qe)/;
      }
  
      $Regexp::Common::comment [$count] = qr/$re/;
  }
  
  #
  # Process data.
  #
  
  foreach my $info (@plain_or_nested) {
      my ($language, $mark, $begin, $end) = @$info;
      pattern name    => [comment => $language],
              create  =>
                  sub {my $re     = nested $begin => $end;
                       my $prefix = defined $mark ? $mark . "[^\n]*\n|" : "";
                       exists $_ [1] -> {-keep} ? qr /($prefix$re)/
                                                : qr  /$prefix$re/
                  },
              version => 5.006,
              ;
  }
  
  
  foreach my $group (@generic) {
      my $pattern = combine +(map {to_eol   $_} @{$group -> {to_eol}}),
                             (map {from_to @$_} @{$group -> {from_to}}),
                             (map {id       $_} @{$group -> {id}}),
                    ;
      foreach my $language  (@{$group -> {languages}}) {
          pattern name    => [comment => ref $language ? @$language : $language],
                  create  => $pattern,
                  ;
      }
  }
                  
  
      
  #
  # Other languages.
  #
  
  # http://www.pascal-central.com/docs/iso10206.txt
  pattern name    => [qw /comment Pascal/],
          create  => '(?k:' . '(?k:[{]|[(][*])'
                            . '(?k:[^}*]*(?:[*](?![)])[^}*]*)*)'
                            . '(?k:[}]|[*][)])'
                            . ')'
          ;
  
  # http://www.templetons.com/brad/alice/language/
  pattern name    =>  [qw /comment Pascal Alice/],
          create  =>  '(?k:(?k:[{])(?k:[^}\n]*)(?k:[}]))'
          ;
  
  
  # http://westein.arb-phys.uni-dortmund.de/~wb/a68s.txt
  pattern name    => [qw (comment), 'Algol 68'],
          create  => q {(?k:(?:#[^#]*#)|}                           .
                     q {(?:\bco\b(?:[^c]+|\Bc|\bc(?!o\b))*\bco\b)|} .
                     q {(?:\bcomment\b(?:[^c]+|\Bc|\bc(?!omment\b))*\bcomment\b))}
          ;
  
  
  # See rules 91 and 92 of ISO 8879 (SGML).
  # Charles F. Goldfarb: "The SGML Handbook".
  # Oxford: Oxford University Press. 1990. ISBN 0-19-853737-9.
  # Ch. 10.3, pp 390.
  pattern name    => [qw (comment HTML)],
          create  => q {(?k:(?k:<!)(?k:(?:--(?k:[^-]*(?:-[^-]+)*)--\s*)*)(?k:>))},
          ;
  
  
  pattern name    => [qw /comment SQL MySQL/],
          create  => q {(?k:(?:#|-- )[^\n]*\n|} .
                     q {/\*(?:(?>[^*;"']+)|"[^"]*"|'[^']*'|\*(?!/))*(?:;|\*/))},
          ;
  
  # Anything that isn't <>[]+-.,
  # http://home.wxs.nl/~faase009/Ha_BF.html
  pattern name    => [qw /comment Brainfuck/],
          create  => '(?k:[^<>\[\]+\-.,]+)'
          ;
  
  # Squeak is a variant of Smalltalk-80.
  # http://www.squeak.
  # http://mucow.com/squeak-qref.html
  pattern name    => [qw /comment Squeak/],
          create  => '(?k:(?k:")(?k:[^"]*(?:""[^"]*)*)(?k:"))'
          ;
  
  #
  # Scores of less than 5 or above 17....
  # http://www.cliff.biffle.org/esoterica/beatnik.html
  @Regexp::Common::comment::scores = (1,  3,  3,  2,  1,  4,  2,  4,  1,  8,
                                      5,  1,  3,  1,  1,  3, 10,  1,  1,  1,
                                      1,  4,  4,  8,  4, 10);
  {
  my ($s, $x);
  pattern name    =>  [qw /comment Beatnik/],
          create  =>  sub {
              use re 'eval';
              my $re = qr {\b([A-Za-z]+)\b
                           (?(?{($s, $x) = (0, lc $^N);
                                $s += $Regexp::Common::comment::scores
                                      [ord (chop $x) - ord ('a')] while length $x;
                                $s  >= 5 && $s < 18})XXX|)}x;
              $re;
          },
          version  => 5.008,
          ;
  }
  
  
  # http://www.cray.com/craydoc/manuals/007-3692-005/html-007-3692-005/
  #  (Goto table of contents/3.3 Source Form)
  # Fortran, in fixed format. Comments start with a C, c or * in the first
  # column, or a ! anywhere, but the sixth column. Then end with a newline.
  pattern name    =>  [qw /comment Fortran fixed/],
          create  =>  '(?k:(?k:(?:^[Cc*]|(?<!^.....)!))(?k:[^\n]*)(?k:\n))'
          ;
  
  
  # http://www.csis.ul.ie/cobol/Course/COBOLIntro.htm
  # Traditionally, comments in COBOL were indicated with an asteriks in
  # the seventh column. Modern compilers may be more lenient.
  pattern name    =>  [qw /comment COBOL/],
          create  =>  '(?<=^......)(?k:(?k:[*])(?k:[^\n]*)(?k:\n))',
          version =>  '5.008',
          ;
  
  1;
  
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::comment -- provide regexes for comments.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /comment/;
  
      while (<>) {
          /$RE{comment}{C}/       and  print "Contains a C comment\n";
          /$RE{comment}{C++}/     and  print "Contains a C++ comment\n";
          /$RE{comment}{PHP}/     and  print "Contains a PHP comment\n";
          /$RE{comment}{Java}/    and  print "Contains a Java comment\n";
          /$RE{comment}{Perl}/    and  print "Contains a Perl comment\n";
          /$RE{comment}{awk}/     and  print "Contains an awk comment\n";
          /$RE{comment}{HTML}/    and  print "Contains an HTML comment\n";
      }
  
      use Regexp::Common qw /comment RE_comment_HTML/;
  
      while (<>) {
          $_ =~ RE_comment_HTML() and  print "Contains an HTML comment\n";
      }
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  This modules gives you regular expressions for comments in various
  languages.
  
  =head2 THE LANGUAGES
  
  Below, the comments of each of the languages are described.
  The patterns are available as C<$RE{comment}{I<LANG>}>, foreach
  language I<LANG>. Some languages have variants; it's described
  at the individual languages how to get the patterns for the variants.
  Unless mentioned otherwise,
  C<{-keep}> sets C<$1>, C<$2>, C<$3> and C<$4> to the entire comment,
  the opening marker, the content of the comment, and the closing marker
  (for many languages, the latter is a newline) respectively.
  
  =over 4
  
  =item ABC
  
  Comments in I<ABC> start with a backslash (C<\>), and last till
  the end of the line.
  See L<http://homepages.cwi.nl/%7Esteven/abc/>.
  
  =item Ada
  
  Comments in I<Ada> start with C<-->, and last till the end of the line.
  
  =item Advisor
  
  I<Advisor> is a language used by the HP product I<glance>. Comments for
  this language start with either C<#> or C<//>, and last till the
  end of the line.
  
  =item Advsys
  
  Comments for the I<Advsys> language start with C<;> and last till
  the end of the line. See also L<http://www.wurb.com/if/devsys/12>.
  
  =item Alan
  
  I<Alan> comments start with C<-->, and last till the end of the line.
  See also L<http://w1.132.telia.com/~u13207378/alan/manual/alanTOC.html>.
  
  =item Algol 60
  
  Comments in the I<Algol 60> language start with the keyword C<comment>,
  and end with a C<;>. See L<http://www.masswerk.at/algol60/report.htm>.
  
  =item Algol 68
  
  In I<Algol 68>, comments are either delimited by C<#>, or by one of the
  keywords C<co> or C<comment>. The keywords should not be part of another
  word. See L<http://westein.arb-phys.uni-dortmund.de/~wb/a68s.txt>.
  With C<{-keep}>, only C<$1> will be set, returning the entire comment.
  
  =item ALPACA
  
  The I<ALPACA> language has comments starting with C</*> and ending with C<*/>.
  
  =item awk
  
  The I<awk> programming language uses comments that start with C<#>
  and end at the end of the line.
  
  =item B
  
  The I<B> language has comments starting with C</*> and ending with C<*/>.
  
  =item BASIC
  
  There are various forms of BASIC around. Currently, we only support the
  variant supported by I<mvEnterprise>, whose pattern is available as
  C<$RE{comment}{BASIC}{mvEnterprise}>. Comments in this language start with a
  C<!>, a C<*> or the keyword C<REM>, and end till the end of the line. See
  L<http://www.rainingdata.com/products/beta/docs/mve/50/ReferenceManual/Basic.pdf>.
  
  =item Beatnik
  
  The esotoric language I<Beatnik> only uses words consisting of letters.
  Words are scored according to the rules of Scrabble. Words scoring less
  than 5 points, or 18 points or more are considered comments (although
  the compiler might mock at you if you score less than 5 points).
  Regardless whether C<{-keep}>, C<$1> will be set, and set to the
  entire comment. This pattern requires I<perl 5.8.0> or newer.
  
  =item beta-Juliet
  
  The I<beta-Juliet> programming language has comments that start with
  C<//> and that continue till the end of the line. See also
  L<http://www.catseye.mb.ca/esoteric/b-juliet/index.html>.
  
  =item Befunge-98
  
  The esotoric language I<Befunge-98> uses comments that start and end
  with a C<;>. See L<http://www.catseye.mb.ca/esoteric/befunge/98/spec98.html>.
  
  =item BML                 
  
  I<BML>, or I<Better Markup Language> is an HTML templating language that
  uses comments starting with C<< <?c_ >>, and ending with C<< c_?> >>.
  See L<http://www.livejournal.com/doc/server/bml.index.html>.               
  
  =item Brainfuck
  
  The minimal language I<Brainfuck> uses only eight characters, 
  C<E<lt>>, C<E<gt>>, C<[>, C<]>, C<+>, C<->, C<.> and C<,>.
  Any other characters are considered comments. With C<{-keep}>,
  C<$1> is set to the entire comment.
  
  =item C
  
  The I<C> language has comments starting with C</*> and ending with C<*/>.
  
  =item C--
  
  The I<C--> language has comments starting with C</*> and ending with C<*/>.
  See L<http://cs.uas.arizona.edu/classes/453/programs/C--Spec.html>.
  
  =item C++
  
  The I<C++> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment.
  
  =item C#
  
  The I<C#> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment.
  See L<http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csspec/html/vclrfcsharpspec_C.asp>.
  
  =item Caml
  
  Comments in I<Caml> start with C<(*>, end with C<*)>, and can be nested.
  See L<http://www.cs.caltech.edu/courses/cs134/cs134b/book.pdf> and
  L<http://pauillac.inria.fr/caml/index-eng.html>.
  
  =item Cg
  
  The I<Cg> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment.
  See L<http://developer.nvidia.com/attach/3722>.
  
  =item CLU
  
  In C<CLU>, a comment starts with a procent sign (C<%>), and ends with the
  next newline. See L<ftp://ftp.lcs.mit.edu:/pub/pclu/CLU-syntax.ps> and
  L<http://www.pmg.lcs.mit.edu/CLU.html>.
  
  =item COBOL
  
  Traditionally, comments in I<COBOL> are indicated by an asteriks in the
  seventh column. This is what the pattern matches. Modern compiler may
  more lenient though. See L<http://www.csis.ul.ie/cobol/Course/COBOLIntro.htm>,
  and L<http://www.csis.ul.ie/cobol/default.htm>. Due to a bug in the regexp
  engine of perl 5.6.x, this regexp is only available in version 5.8.0 and up.
  
  =item CQL
  
  Comments in the chess query language (I<CQL>) start with a semi colon
  (C<;>) and last till the end of the line. See L<http://www.rbnn.com/cql/>.
  
  =item Crystal Report
  
  The formula editor in I<Crystal Reports> uses comments that start
  with C<//>, and end with the end of the line.
  
  =item Dylan
  
  There are two types of comments in I<Dylan>. They either start with
  C<//>, or are nested comments, delimited with C</*> and C<*/>.
  Under C<{-keep}>, only C<$1> will be set, returning the entire comment.
  This pattern requires I<perl 5.6.0> or newer.
  
  =item ECMAScript
  
  The I<ECMAScript> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment. I<JavaScript> is Netscapes implementation
  of I<ECMAScript>. See
  L<http://www.ecma-international.org/publications/files/ecma-st/Ecma-262.pdf>,
  and L<http://www.ecma-international.org/publications/standards/Ecma-262.htm>.
  
  =item Eiffel
  
  I<Eiffel> comments start with C<-->, and last till the end of the line.
  
  =item False
  
  In I<False>, comments start with C<{> and end with C<}>.
  See L<http://wouter.fov120.com/false/false.txt>
  
  =item FPL
  
  The I<FPL> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment.
  
  =item Forth
  
  Comments in Forth start with C<\>, and end with the end of the line.
  See also L<http://docs.sun.com/sb/doc/806-1377-10>.
  
  =item Fortran
  
  There are two forms of I<Fortran>. There's free form I<Fortran>, which
  has comments that start with C<!>, and end at the end of the line.
  The pattern for this is given by C<$RE{Fortran}>. Fixed form I<Fortran>,
  which has been obsoleted, has comments that start with C<C>, C<c> or
  C<*> in the first column, or with C<!> anywhere, but the sixth column.
  The pattern for this are given by C<$RE{Fortran}{fixed}>.
  
  See also L<http://www.cray.com/craydoc/manuals/007-3692-005/html-007-3692-005/>.
  
  =item Funge-98
  
  The esotoric language I<Funge-98> uses comments that start and end with
  a C<;>.
  
  =item fvwm2
  
  Configuration files for I<fvwm2> have comments starting with a
  C<#> and lasting the rest of the line.
  
  =item Haifu
  
  I<Haifu>, an esotoric language using haikus, has comments starting and
  ending with a C<,>.
  See L<http://www.dangermouse.net/esoteric/haifu.html>.
  
  =item Haskell
  
  There are two types of comments in I<Haskell>. They either start with
  at least two dashes, or are nested comments, delimited with C<{-> and C<-}>.
  Under C<{-keep}>, only C<$1> will be set, returning the entire comment.
  This pattern requires I<perl 5.6.0> or newer.
  
  =item HTML
  
  In I<HTML>, comments only appear inside a I<comment declaration>.
  A comment declaration starts with a C<E<lt>!>, and ends with a
  C<E<gt>>. Inside this declaration, we have zero or more comments.
  Comments starts with C<--> and end with C<-->, and are optionally
  followed by whitespace. The pattern C<$RE{comment}{HTML}> recognizes
  those comment declarations (and hence more than a comment).
  Note that this is not the same as something that starts with
  C<E<lt>!--> and ends with C<--E<gt>>, because the following will
  be matched completely:
  
      <!--  First  Comment   --
        --> Second Comment <!--
        --  Third  Comment   -->
  
  Do not be fooled by what your favourite browser thinks is an HTML
  comment.
  
  If C<{-keep}> is used, the following are returned:
  
  =over 4
  
  =item $1
  
  captures the entire comment declaration.
  
  =item $2
  
  captures the MDO (markup declaration open), C<E<lt>!>.
  
  =item $3
  
  captures the content between the MDO and the MDC.
  
  =item $4
  
  captures the (last) comment, without the surrounding dashes.
  
  =item $5
  
  captures the MDC (markup declaration close), C<E<gt>>.
  
  =back
  
  =item Hugo
  
  There are two types of comments in I<Hugo>. They either start with
  C<!> (which cannot be followed by a C<\>), or are nested comments,
  delimited with C<!\> and C<\!>.
  Under C<{-keep}>, only C<$1> will be set, returning the entire comment.
  This pattern requires I<perl 5.6.0> or newer.
  
  =item Icon
  
  I<Icon> has comments that start with C<#> and end at the next new line.
  See L<http://www.toolsofcomputing.com/IconHandbook/IconHandbook.pdf>,
  L<http://www.cs.arizona.edu/icon/index.htm>, and
  L<http://burks.bton.ac.uk/burks/language/icon/index.htm>.
  
  =item ILLGOL
  
  The esotoric language I<ILLGOL> uses comments starting with I<NB> and lasting
  till the end of the line.
  See L<http://www.catseye.mb.ca/esoteric/illgol/index.html>.
  
  =item INTERCAL
  
  Comments in INTERCAL are single line comments. They start with one of
  the keywords C<NOT> or C<N'T>, and can optionally be preceeded by the
  keywords C<DO> and C<PLEASE>. If both keywords are used, C<PLEASE>
  preceeds C<DO>. Keywords are separated by whitespace.
  
  =item J
  
  The language I<J> uses comments that start with C<NB.>, and that last till
  the end of the line. See
  L<http://www.jsoftware.com/books/help/primer/contents.htm>, and
  L<http://www.jsoftware.com/>.
  
  =item Java
  
  The I<Java> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment.
  
  =item JavaScript
  
  The I<JavaScript> language has two forms of comments. Comments that start with
  C<//> and last till the end of the line, and comments that start with
  C</*>, and end with C<*/>. If C<{-keep}> is used, only C<$1> will be
  set, and set to the entire comment. I<JavaScript> is Netscapes implementation
  of I<ECMAScript>.
  See L<http://www.mozilla.org/js/language/E262-3.pdf>,
  and L<http://www.mozilla.org/js/language/>.
  
  =item LaTeX
  
  The documentation language I<LaTeX> uses comments starting with C<%>
  and ending at the end of the line.
  
  =item Lisp
  
  Comments in I<Lisp> start with a semi-colon (C<;>) and last till the
  end of the line.
  
  =item LPC
  
  The I<LPC> language has comments starting with C</*> and ending with C<*/>.
  
  =item LOGO
  
  Comments for the language I<LOGO> start with C<;>, and last till the end
  of the line.
  
  =item lua
  
  Comments for the I<lua> language start with C<-->, and last till the end
  of the line. See also L<http://www.lua.org/manual/manual.html>.
  
  =item M, MUMPS
  
  In C<M> (aka C<MUMPS>), comments start with a semi-colon, and last
  till the end of a line. The language specification requires the 
  semi-colon to be preceeded by one or more I<linestart character>s.
  Those characters default to a space, but that's configurable. This
  requirement, of preceeding the comment with linestart characters is
  B<not> tested for. See
  L<ftp://ftp.intersys.com/pub/openm/ism/ism64docs.zip>,
  L<http://mtechnology.intersys.com/mproducts/openm/index.html>, and
  L<http://mcenter.com/mtrc/index.html>.
  
  =item m4
  
  By default, the preprocessor language I<m4> uses single line comments,
  that start with a C<#> and continue to the end of the line, including
  the newline. The pattern C<$RE {comment} {m4}> matches such comments.
  In I<m4>, it is possible to change the starting token though.
  See L<http://wolfram.schneider.org/bsd/7thEdManVol2/m4/m4.pdf>,
  L<http://www.cs.stir.ac.uk/~kjt/research/pdf/expl-m4.pdf>, and
  L<http://www.gnu.org/software/m4/manual/>.
  
  =item Modula-2
  
  In C<Modula-2>, comments start with C<(*>, and end with C<*)>. Comments
  may be nested. See L<http://www.modula2.org/>.
  
  =item Modula-3
  
  In C<Modula-3>, comments start with C<(*>, and end with C<*)>. Comments
  may be nested. See L<http://www.m3.org/>.
  
  =item mutt
  
  Configuration files for I<mutt> have comments starting with a
  C<#> and lasting the rest of the line.
  
  =item Nickle
  
  The I<Nickle> language has one line comments starting with C<#>
  (like Perl), or multiline comments delimited by C</*> and C<*/>
  (like C). Under C<-keep>, only C<$1> will be set. See also
  L<http://www.nickle.org>.
  
  =item Oberon
  
  Comments in I<Oberon> start with C<(*> and end with C<*)>.
  See L<http://www.oberon.ethz.ch/oreport.html>.
  
  =item Pascal
  
  There are many implementations of Pascal. This modules provides
  pattern for comments of several implementations.
  
  =over 4
  
  =item C<$RE{comment}{Pascal}>
  
  This is the pattern that recognizes comments according to the Pascal ISO 
  standard. This standard says that comments start with either C<{>, or
  C<(*>, and end with C<}> or C<*)>. This means that C<{*)> and C<(*}>
  are considered to be comments. Many Pascal applications don't allow this.
  See L<http://www.pascal-central.com/docs/iso10206.txt>
  
  =item C<$RE{comment}{Alice}>
  
  The I<Alice Pascal> compiler accepts comments that start with C<{>
  and end with C<}>. Comments are not allowed to contain newlines.
  See L<http://www.templetons.com/brad/alice/language/>.
  
  =item C<$RE{comment}{Pascal}{Delphi}>, C<$RE{comment}{Pascal}{Free}>
  and C<$RE{comment}{Pascal}{GPC}>
  
  The I<Delphi Pascal>, I<Free Pascal> and the I<Gnu Pascal Compiler>
  implementations of Pascal all have comments that either start with
  C<//> and last till the end of the line, are delimited with C<{>
  and C<}> or are delimited with C<(*> and C<*)>. Patterns for those
  comments are given by C<$RE{comment}{Pascal}{Delphi}>, 
  C<$RE{comment}{Pascal}{Free}> and C<$RE{comment}{Pascal}{GPC}>
  respectively. These patterns only set C<$1> when C<{-keep}> is used,
  which will then include the entire comment.
  
  See L<http://info.borland.com/techpubs/delphi5/oplg/>, 
  L<http://www.freepascal.org/docs-html/ref/ref.html> and
  L<http://www.gnu-pascal.de/gpc/>.
  
  =item C<$RE{comment}{Pascal}{Workshop}>
  
  The I<Workshop Pascal> compiler, from SUN Microsystems, allows comments
  that are delimited with either C<{> and C<}>, delimited with
  C<(*)> and C<*>), delimited with C</*>, and C<*/>, or starting
  and ending with a double quote (C<">). When C<{-keep}> is used,
  only C<$1> is set, and returns the entire comment.
  
  See L<http://docs.sun.com/db/doc/802-5762>.
  
  =back
  
  =item PEARL
  
  Comments in I<PEARL> start with a C<!> and last till the end of the
  line, or start with C</*> and end with C<*/>. With C<{-keep}>, 
  C<$1> will be set to the entire comment.
  
  =item PHP
  
  Comments in I<PHP> start with either C<#> or C<//> and last till the
  end of the line, or are delimited by C</*> and C<*/>. With C<{-keep}>,
  C<$1> will be set to the entire comment.
  
  =item PL/B
  
  In I<PL/B>, comments start with either C<.> or C<;>, and end with the 
  next newline. See L<http://www.mmcctech.com/pl-b/plb-0010.htm>.
  
  =item PL/I
  
  The I<PL/I> language has comments starting with C</*> and ending with C<*/>.
  
  =item PL/SQL
  
  In I<PL/SQL>, comments either start with C<--> and run till the end
  of the line, or start with C</*> and end with C<*/>.
  
  =item Perl
  
  I<Perl> uses comments that start with a C<#>, and continue till the end
  of the line.
  
  =item Portia
  
  The I<Portia> programming language has comments that start with C<//>,
  and last till the end of the line.
  
  =item Python
  
  I<Python> uses comments that start with a C<#>, and continue till the end
  of the line.
  
  =item Q-BAL
  
  Comments in the I<Q-BAL> language start with C<`> (a backtick), and
  contine till the end of the line.
  
  =item QML
  
  In C<QML>, comments start with C<#> and last till the end of the line.
  See L<http://www.questionmark.com/uk/qml/overview.doc>.
  
  =item R
  
  The statistical language I<R> uses comments that start with a C<#> and
  end with the following new line. See L<http://www.r-project.org/>.
  
  =item REBOL
  
  Comments for the I<REBOL> language start with C<;> and last till the
  end of the line.
  
  =item Ruby
  
  Comments in I<Ruby> start with C<#> and last till the end of the time.
  
  =item Scheme
  
  I<Scheme> comments start with C<;>, and last till the end of the line.
  See L<http://schemers.org/>.
  
  =item shell
  
  Comments in various I<shell>s start with a C<#> and end at the end of
  the line.
  
  =item Shelta
  
  The esotoric language I<Shelta> uses comments that start and end with
  a C<;>. See L<http://www.catseye.mb.ca/esoteric/shelta/index.html>.
  
  =item SLIDE
  
  The I<SLIDE> language has two froms of comments. First there is the
  line comment, which starts with a C<#> and includes the rest of the
  line (just like Perl). Second, there is the multiline, nested comment,
  which are delimited by C<(*> and C<*)>. Under C{-keep}>, only 
  C<$1> is set, and is set to the entire comment. This pattern needs
  at least Perl version 5.6.0. See
  L<http://www.cs.berkeley.edu/~ug/slide/docs/slide/spec/spec_frame_intro.shtml>.
  
  =item slrn
  
  Configuration files for I<slrn> have comments starting with a
  C<%> and lasting the rest of the line.
  
  =item Smalltalk
  
  I<Smalltalk> uses comments that start and end with a double quote, C<">.
  
  =item SMITH
  
  Comments in the I<SMITH> language start with C<;>, and last till the
  end of the line.
  
  =item Squeak
  
  In the Smalltalk variant I<Squeak>, comments start and end with
  C<">. Double quotes can appear inside comments by doubling them.
  
  =item SQL
  
  Standard I<SQL> uses comments starting with two or more dashes, and
  ending at the end of the line. 
  
  I<MySQL> does not follow the standard. Instead, it allows comments
  that start with a C<#> or C<-- > (that's two dashes and a space)
  ending with the following newline, and comments starting with 
  C</*>, and ending with the next C<;> or C<*/> that isn't inside
  single or double quotes. A pattern for this is returned by
  C<$RE{comment}{SQL}{MySQL}>. With C<{-keep}>, only C<$1> will
  be set, and it returns the entire comment.
  
  =item Tcl
  
  In I<Tcl>, comments start with C<#> and continue till the end of the line.
  
  =item TeX
  
  The documentation language I<TeX> uses comments starting with C<%>
  and ending at the end of the line.
  
  =item troff
  
  The document formatting language I<troff> uses comments starting
  with C<\">, and continuing till the end of the line.
  
  =item Ubercode
  
  The Windows programming language I<Ubercode> uses comments that start with
  C<//> and continue to the end of the line. See L<http://www.ubercode.com>.
  
  =item vi
  
  In configuration files for the editor I<vi>, one can use comments
  starting with C<">, and ending at the end of the line.
  
  =item *W
  
  In the language I<*W>, comments start with C<||>, and end with C<!!>.
  
  =item zonefile
  
  Comments in DNS I<zonefile>s start with C<;>, and continue till the
  end of the line.
  
  =item ZZT-OOP
  
  The in-game language I<ZZT-OOP> uses comments that start with a C<'> 
  character, and end at the following newline. See
  L<http://dave2.rocketjump.org/rad/zzthelp/lang.html>.
  
  =back
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<[Go 90]>
  
  Charles F. Goldfarb: I<The SGML Handbook>. Oxford: Oxford University
  Press. B<1990>. ISBN 0-19-853737-9. Ch. 10.3, pp 390-391.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_COMMENT

$fatpacked{"Regexp/Common/delimited.pm"} = <<'REGEXP_COMMON_DELIMITED';
  package Regexp::Common::delimited;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  sub gen_delimited {
  
      my ($dels, $escs) = @_;
      # return '(?:\S*)' unless $dels =~ /\S/;
      if (length $escs) {
          $escs .= substr ($escs, -1) x (length ($dels) - length ($escs));
      }
      my @pat = ();
      my $i;
      for ($i=0; $i < length $dels; $i++) {
          my $del = quotemeta substr ($dels, $i, 1);
          my $esc = length($escs) ? quotemeta substr ($escs, $i, 1) : "";
          if ($del eq $esc) {
              push @pat,
                   "(?k:$del)(?k:[^$del]*(?:(?:$del$del)[^$del]*)*)(?k:$del)";
          }
          elsif (length $esc) {
              push @pat,
                   "(?k:$del)(?k:[^$esc$del]*(?:$esc.[^$esc$del]*)*)(?k:$del)";
          }
          else {
              push @pat, "(?k:$del)(?k:[^$del]*)(?k:$del)";
          }
      }
      my $pat = join '|', @pat;
      return "(?k:$pat)";
  }
  
  sub _croak {
      require Carp;
      goto &Carp::croak;
  }
  
  pattern name   => [qw( delimited -delim= -esc=\\ )],
          create => sub {my $flags = $_[1];
                         _croak 'Must specify delimiter in $RE{delimited}'
                               unless length $flags->{-delim};
                         return gen_delimited (@{$flags}{-delim, -esc});
                    },
          ;
  
  pattern name   => [qw( quoted -esc=\\ )],
          create => sub {my $flags = $_[1];
                         return gen_delimited (q{"'`}, $flags -> {-esc});
                    },
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::delimited -- provides a regex for delimited strings
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /delimited/;
  
      while (<>) {
          /$RE{delimited}{-delim=>'"'}/  and print 'a \" delimited string';
          /$RE{delimited}{-delim=>'/'}/  and print 'a \/ delimited string';
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{delimited}{-delim}{-esc}>
  
  Returns a pattern that matches a single-character-delimited substring,
  with optional internal escaping of the delimiter.
  
  When C<-delim=I<S>> is specified, each character in the sequence I<S> is
  a possible delimiter. There is no default delimiter, so this flag must always
  be specified.
  
  If C<-esc=I<S>> is specified, each character in the sequence I<S> is
  the delimiter for the corresponding character in the C<-delim=I<S>> list.
  The default escape is backslash.
  
  For example:
  
     $RE{delimited}{-delim=>'"'}            # match "a \" delimited string"
     $RE{delimited}{-delim=>'"'}{-esc=>'"'} # match "a "" delimited string"
     $RE{delimited}{-delim=>'/'}            # match /a \/ delimited string/
     $RE{delimited}{-delim=>q{'"}}          # match "string" or 'string'
  
  Under C<-keep> (See L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire match
  
  =item $2
  
  captures the opening delimiter (provided only one delimiter was specified)
  
  =item $3
  
  captures delimited portion of the string (provided only one delimiter was
  specified)
  
  =item $4
  
  captures the closing delimiter (provided only one delimiter was specified)
  
  =back
  
  =head2 $RE{quoted}{-esc}
  
  A synonym for C<$RE{delimited}{q{-delim='"`}{...}}>
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_DELIMITED

$fatpacked{"Regexp/Common/lingua.pm"} = <<'REGEXP_COMMON_LINGUA';
  package Regexp::Common::lingua;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  pattern name    => [qw /lingua palindrome -chars=[A-Za-z]/],
          create  => sub {
              use re 'eval';
              my $keep = exists $_ [1] -> {-keep};
              my $ch   = $_ [1] -> {-chars};
              my $idx  = $keep ? "1:$ch" : "0:$ch";
              my $r    = "(??{\$Regexp::Common::lingua::pd{'" . $idx . "'}})";
              $Regexp::Common::lingua::pd {$idx} = 
                      $keep ? qr /($ch|($ch)($r)?\2)/ : qr  /$ch|($ch)($r)?\1/;
          #   print "[$ch]: ", $Regexp::Common::lingua::pd {$idx}, "\n";
          #   $Regexp::Common::lingua::pd {$idx};
          },
          version => 5.006
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::lingua -- provide regexes for language related stuff.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /lingua/;
  
      while (<>) {
          /^$RE{lingua}{palindrome}$/    and  print "is a palindrome\n";
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{lingua}{palindrome}>
  
  Returns a pattern that recognizes a palindrome, a string that is the
  same if you reverse it. By default, it only matches strings consisting
  of letters, but this can be changed using the C<{-chars}> option.
  This option takes a character class (default is C<[A-Za-z]>) as
  argument.
  
  If C<{-keep}> is used, only C<$1> will be set, and set to the entire
  match. 
  
  This pattern requires at least perl 5.6.0.
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Many regexes are missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_LINGUA

$fatpacked{"Regexp/Common/list.pm"} = <<'REGEXP_COMMON_LIST';
  package Regexp::Common::list;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  sub gen_list_pattern {
      my ($pat, $sep, $lsep) = @_;
      $lsep = $sep unless defined $lsep;
      return "(?k:(?:(?:$pat)(?:$sep))*(?:$pat)(?k:$lsep)(?:$pat))";
  }
  
  my $defpat = '.*?\S';
  my $defsep = '\s*,\s*';
  
  pattern name   => ['list', "-pat=$defpat", "-sep=$defsep", '-lastsep'],
          create => sub {gen_list_pattern (@{$_[1]}{-pat, -sep, -lastsep})},
          ;
  
  pattern name   => ['list', 'conj', '-word=(?:and|or)'],
          create => sub {gen_list_pattern($defpat, $defsep,
                                          '\s*,?\s*'.$_[1]->{-word}.'\s*');
                    },
          ;
  
  pattern name   => ['list', 'and'],
          create => sub {gen_list_pattern ($defpat, $defsep, '\s*,?\s*and\s*')},
          ;
  
  pattern name   => ['list', 'or'],
          create => sub {gen_list_pattern ($defpat, $defsep, '\s*,?\s*or\s*')},
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::list -- provide regexes for lists
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /list/;
  
      while (<>) {
          /$RE{list}{-pat => '\w+'}/          and print "List of words";
          /$RE{list}{-pat => $RE{num}{real}}/ and print "List of numbers";
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{list}{-pat}{-sep}{-lastsep}>
  
  Returns a pattern matching a list of (at least two) substrings.
  
  If C<-pat=I<P>> is specified, it defines the pattern for each substring
  in the list. By default, I<P> is C<qr/.*?\S/>. In Regexp::Common 0.02
  or earlier, the default pattern was C<qr/.*?/>. But that will match
  a single space, causing unintended parsing of C<a, b, and c> as a
  list of four elements instead of 3 (with C<-word> being C<(?:and)>).
  One consequence is that a list of the form "a,,b" will no longer be
  parsed. Use the pattern C<qr /.*?/> to be able to parse this, but see
  the previous remark.
  
  If C<-sep=I<P>> is specified, it defines the pattern I<P> to be used as
  a separator between each pair of substrings in the list, except the final two.
  By default I<P> is C<qr/\s*,\s*/>.
  
  If C<-lastsep=I<P>> is specified, it defines the pattern I<P> to be used as
  a separator between the final two substrings in the list.
  By default I<P> is the same as the pattern specified by the C<-sep> flag.
  
  For example:
  
        $RE{list}{-pat=>'\w+'}                # match a list of word chars
        $RE{list}{-pat=>$RE{num}{real}}       # match a list of numbers
        $RE{list}{-sep=>"\t"}                 # match a tab-separated list
        $RE{list}{-lastsep=>',\s+and\s+'}     # match a proper English list
  
  Under C<-keep>:
  
  =over 4
  
  =item $1
  
  captures the entire list
  
  =item $2
  
  captures the last separator
  
  =back
  
  =head2 C<$RE{list}{conj}{-word=I<PATTERN>}>
  
  An alias for C<< $RE{list}{-lastsep=>'\s*,?\s*I<PATTERN>\s*'} >>
  
  If C<-word> is not specified, the default pattern is C<qr/and|or/>.
  
  For example:
  
        $RE{list}{conj}{-word=>'et'}        # match Jean, Paul, et Satre
        $RE{list}{conj}{-word=>'oder'}      # match Bonn, Koln oder Hamburg
  
  =head2 C<$RE{list}{and}>
  
  An alias for C<< $RE{list}{conj}{-word=>'and'} >>
  
  =head2 C<$RE{list}{or}>
  
  An alias for C<< $RE{list}{conj}{-word=>'or'} >>
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_LIST

$fatpacked{"Regexp/Common/net.pm"} = <<'REGEXP_COMMON_NET';
  package Regexp::Common::net;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  my %IPunit = (
      dec => q{(?k:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})},
      oct => q{(?k:[0-3]?[0-7]{1,2})},
      hex => q{(?k:[0-9a-fA-F]{1,2})},
      bin => q{(?k:[0-1]{1,8})},
  );
  my %MACunit = (
      %IPunit,
      hex => q{(?k:[0-9a-fA-F]{1,2})},
  );
  
  sub dec {$_};
  sub bin {oct "0b$_"}
  
  my $IPdefsep  = '[.]';
  my $MACdefsep =  ':';
  
  pattern name   => [qw (net IPv4)],
          create => "(?k:$IPunit{dec}$IPdefsep$IPunit{dec}$IPdefsep" .
                        "$IPunit{dec}$IPdefsep$IPunit{dec})",
          ;
  
  pattern name   => [qw (net MAC)],
          create => "(?k:" . join ($MACdefsep => ($MACunit{hex}) x 6) . ")",
          subs   => sub {
              $_ [1] = join ":" => map {sprintf "%02x" => hex}
                                   split /$MACdefsep/ => $_ [1]
                       if $_ [1] =~ /$_[0]/
          },
          ;
  
  foreach my $type (qw /dec oct hex bin/) {
      pattern name   => [qw (net IPv4), $type, "-sep=$IPdefsep"],
              create => sub {my $sep = $_ [1] -> {-sep};
                             "(?k:$IPunit{$type}$sep$IPunit{$type}$sep" .
                                 "$IPunit{$type}$sep$IPunit{$type})"
                        },
              ;
  
      pattern name   => [qw (net MAC), $type, "-sep=$MACdefsep"],
              create => sub {my $sep = $_ [1] -> {-sep};
                             "(?k:" . join ($sep => ($MACunit{$type}) x 6) . ")",
                        },
              subs   => sub {
                  return if $] < 5.006 and $type eq 'bin';
                  $_ [1] = join ":" => map {sprintf "%02x" => eval $type}
                                       $2, $3, $4, $5, $6, $7
                           if $_ [1] =~ $RE {net} {MAC} {$type}
                                            {-sep => $_ [0] -> {flags} {-sep}}
                                            {-keep};
              },
              ;
  
  }
  
  my $letter      =  "[A-Za-z]";
  my $let_dig     =  "[A-Za-z0-9]";
  my $let_dig_hyp = "[-A-Za-z0-9]";
  
  # Domain names, from RFC 1035.
  pattern name   => [qw (net domain -nospace=)],
          create => sub {
              if (exists $_ [1] {-nospace} && !defined $_ [1] {-nospace}) {
                  return "(?k:$letter(?:(?:$let_dig_hyp){0,61}$let_dig)?" .
                         "(?:\\.$letter(?:(?:$let_dig_hyp){0,61}$let_dig)?)*)"
              }
              else {
                  return "(?k: |(?:$letter(?:(?:$let_dig_hyp){0,61}$let_dig)?" .
                         "(?:\\.$letter(?:(?:$let_dig_hyp){0,61}$let_dig)?)*))"
              }
          },
          ;
  
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Regexp::Common::net -- provide regexes for IPv4 addresses.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /net/;
  
      while (<>) {
          /$RE{net}{IPv4}/       and print "Dotted decimal IP address";
          /$RE{net}{IPv4}{hex}/  and print "Dotted hexadecimal IP address";
          /$RE{net}{IPv4}{oct}{-sep => ':'}/ and
                                 print "Colon separated octal IP address";
          /$RE{net}{IPv4}{bin}/  and print "Dotted binary IP address";
          /$RE{net}{MAC}/        and print "MAC address";
          /$RE{net}{MAC}{oct}{-sep => " "}/ and
                                 print "Space separated octal MAC address";
      }
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  This modules gives you regular expressions for various style IPv4 
  and MAC (or ethernet) addresses.
  
  =head2 C<$RE{net}{IPv4}>
  
  Returns a pattern that matches a valid IP address in "dotted decimal".
  Note that while C<318.99.183.11> is not a valid IP address, it does
  match C</$RE{net}{IPv4}/>, but this is because C<318.99.183.11> contains
  a valid IP address, namely C<18.99.183.11>. To prevent the unwanted
  matching, one needs to anchor the regexp: C</^$RE{net}{IPv4}$/>.
  
  For this pattern and the next four, under C<-keep> (See L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire match
  
  =item $2
  
  captures the first component of the address
  
  =item $3
  
  captures the second component of the address
  
  =item $4
  
  captures the third component of the address
  
  =item $5
  
  captures the final component of the address
  
  =back
  
  =head2 C<$RE{net}{IPv4}{dec}{-sep}>
  
  Returns a pattern that matches a valid IP address in "dotted decimal"
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/[.]/>. 
  
  =head2 C<$RE{net}{IPv4}{hex}{-sep}>
  
  Returns a pattern that matches a valid IP address in "dotted hexadecimal",
  with the letters C<A> to C<F> capitalized.
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/[.]/>. C<< -sep="" >> and
  C<< -sep=" " >> are useful alternatives.
  
  =head2 C<$RE{net}{IPv4}{oct}{-sep}>
  
  Returns a pattern that matches a valid IP address in "dotted octal"
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/[.]/>.
  
  =head2 C<$RE{net}{IPv4}{bin}{-sep}>
  
  Returns a pattern that matches a valid IP address in "dotted binary"
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/[.]/>.
  
  =head2 C<$RE{net}{MAC}>
  
  Returns a pattern that matches a valid MAC or ethernet address as
  colon separated hexadecimals.
  
  For this pattern, and the next four, under C<-keep> (See L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire match
  
  =item $2
  
  captures the first component of the address
  
  =item $3
  
  captures the second component of the address
  
  =item $4
  
  captures the third component of the address
  
  =item $5
  
  captures the fourth component of the address
  
  =item $6
  
  captures the fifth component of the address
  
  =item $7
  
  captures the sixth and final component of the address
  
  =back
  
  This pattern, and the next four, have a C<subs> method as well, which
  will transform a matching MAC address into so called canonical format.
  Canonical format means that every component of the address will be
  exactly two hexadecimals (with a leading zero if necessary), and the
  components will be separated by a colon.
  
  The C<subs> method will not work for binary MAC addresses if the
  Perl version predates 5.6.0.
  
  =head2 C<$RE{net}{MAC}{dec}{-sep}>
  
  Returns a pattern that matches a valid MAC address as colon separated
  decimals.
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/:/>. 
  
  =head2 C<$RE{net}{MAC}{hex}{-sep}>
  
  Returns a pattern that matches a valid MAC address as colon separated
  hexadecimals, with the letters C<a> to C<f> in lower case.
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/:/>.
  
  =head2 C<$RE{net}{MAC}{oct}{-sep}>
  
  Returns a pattern that matches a valid MAC address as colon separated
  octals.
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/:/>.
  
  =head2 C<$RE{net}{MAC}{bin}{-sep}>
  
  Returns a pattern that matches a valid MAC address as colon separated
  binary numbers.
  
  If C<< -sep=I<P> >> is specified the pattern I<P> is used as the separator.
  By default I<P> is C<qr/:/>.
  
  =head2 $RE{net}{domain}
  
  Returns a pattern to match domains (and hosts) as defined in RFC 1035.
  Under I{-keep} only the entire domain name is returned.
  
  RFC 1035 says that a single space can be a domainname too. So, the
  pattern returned by C<$RE{net}{domain}> recognizes a single space
  as well. This is not always what people want. If you want to recognize
  domainnames, but not a space, you can do one of two things, either use
  
      /(?! )$RE{net}{domain}/
  
  or use the C<{-nospace}> option (without an argument).
  
  =head1 REFERENCES
  
  =over 4
  
  =item B<RFC 1035>
  
  Mockapetris, P.: I<DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION>.
  November 1987.
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway I<damian@conway.org>.
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_NET

$fatpacked{"Regexp/Common/number.pm"} = <<'REGEXP_COMMON_NUMBER';
  package Regexp::Common::number;
  
  use Config;
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  sub _croak {
      require Carp;
      goto &Carp::croak;
  }
  
  my $digits = join ("", 0 .. 9, "A" .. "Z");
  
  sub int_creator {
      my $flags = $_ [1];
      my ($sep, $group, $base, $places) =
              @{$flags} {qw /-sep -group -base -places/};
  
      # Deal with the bases.
      _croak "Base must be between 1 and 36" unless $base >=  1 &&
                                                    $base <= 36;
      my $chars = substr $digits, 0, $base;
  
      $sep = ',' if exists $flags -> {-sep} && !defined $flags -> {-sep};
  
      my $max = $group;
         $max = $2 if $group =~ /^\s*(\d+)\s*,\s*(\d+)\s*$/;
  
      my $quant = $places ? "{$places}" : "+";
  
      return $sep ? qq {(?k:(?k:[+-]?)(?k:[$chars]{1,$max}} .
                    qq {(?:$sep} . qq {[$chars]{$group})*))}
                  : qq {(?k:(?k:[+-]?)(?k:[$chars]$quant))}
  }
  
  sub real_creator { 
      my ($base, $places, $radix, $sep, $group, $expon) =
              @{$_[1]}{-base, -places, -radix, -sep, -group, -expon};
      _croak "Base must be between 1 and 36"
             unless $base >= 1 && $base <= 36;
      $sep = ',' if exists $_[1]->{-sep}
                 && !defined $_[1]->{-sep};
      if ($base > 14 && $expon =~ /^[Ee]$/) {$expon = 'G'}
      foreach ($radix, $sep, $expon) {$_ = "[$_]" if 1 == length}
      my $chars = substr $digits, 0, $base;
      return $sep
             ? qq {(?k:(?i)(?k:[+-]?)(?k:(?=[$chars]|$radix)}              .
               qq {(?k:[$chars]{1,$group}(?:(?:$sep)[$chars]{$group})*)}  .
               qq {(?:(?k:$radix)(?k:[$chars]{$places}))?)}                .
               qq {(?:(?k:$expon)(?k:(?k:[+-]?)(?k:[$chars]+))|))}
             : qq {(?k:(?i)(?k:[+-]?)(?k:(?=[$chars]|$radix)}              .
               qq {(?k:[$chars]*)(?:(?k:$radix)(?k:[$chars]{$places}))?)} .
               qq {(?:(?k:$expon)(?k:(?k:[+-]?)(?k:[$chars]+))|))};
  }
  sub decimal_creator { 
      my ($base, $places, $radix, $sep, $group) =
              @{$_[1]}{-base, -places, -radix, -sep, -group};
      _croak "Base must be between 1 and 36"
             unless $base >= 1 && $base <= 36;
      $sep = ',' if exists $_[1]->{-sep}
                 && !defined $_[1]->{-sep};
      foreach ($radix, $sep) {$_ = "[$_]" if 1 == length}
      my $chars = substr $digits, 0, $base;
      return $sep
             ? qq {(?k:(?i)(?k:[+-]?)(?k:(?=[$chars]|$radix)}               .
               qq {(?k:[$chars]{1,$group}(?:(?:$sep)[$chars]{$group})*)}   .
               qq {(?:(?k:$radix)(?k:[$chars]{$places}))?))}
             : qq {(?k:(?i)(?k:[+-]?)(?k:(?=[$chars]|$radix)}               .
               qq {(?k:[$chars]*)(?:(?k:$radix)(?k:[$chars]{$places}))?))}
  }
  
  
  pattern name   => [qw (num int -sep= -base=10 -group=3)],
          create => \&int_creator,
          ;
  
  pattern name   => [qw (num real -base=10), '-places=0,',
                     qw (-radix=[.] -sep= -group=3 -expon=E)],
          create => \&real_creator,
          ;
  
  pattern name   => [qw (num decimal -base=10), '-places=0,',
                     qw (-radix=[.] -sep= -group=3)],
          create => \&decimal_creator,
          ;
  
  sub real_synonym {
      my ($name, $base) = @_;
      pattern name   => ['num', $name, '-places=0,', '-radix=[.]',
                         '-sep=', '-group=3', '-expon=E'],
              create => sub {my %flags = (%{$_[1]}, -base => $base);
                             real_creator (undef, \%flags);
                        }
              ;
  }
  
  
  real_synonym (hex => 16);
  real_synonym (dec => 10);
  real_synonym (oct =>  8);
  real_synonym (bin =>  2);
  
  
  # 2147483647
  pattern name    => [qw (num square)],
          create  => sub {
              use re 'eval';
              my $sixty_four_bits = $Config {use64bitint};
              #
              # CPAN testers claim it fails on 5.8.8 and darwin 9.0.
              #
              $sixty_four_bits = 0 if $Config {osname} eq 'darwin' &&
                                      $Config {osvers} eq '9.0'    &&
                                      $] == 5.008008;
              my $num = $sixty_four_bits ? '0*[1-8]?[0-9]{1,15}' :
                       '0*(?:2(?:[0-0][0-9]{8}' .
                           '|1(?:[0-3][0-9]{7}' .
                           '|4(?:[0-6][0-9]{6}' .
                           '|7(?:[0-3][0-9]{5}' .
                           '|4(?:[0-7][0-9]{4}' .
                           '|8(?:[0-2][0-9]{3}' .
                           '|3(?:[0-5][0-9]{2}' .
                           '|6(?:[0-3][0-9]{1}' .
                           '|4[0-7])))))))))|1?[0-9]{1,9}';
              qr {($num)(?(?{sqrt ($^N) == int sqrt ($^N)})|(?!))}
          },
          version => 5.008;
          ;
  
  pattern name    => [qw (num roman)],
          create  => '(?xi)(?=[MDCLXVI])
                           (?k:M{0,3}
                              (D?C{0,3}|CD|CM)?
                              (L?X{0,3}|XL|XC)?
                              (V?I{0,3}|IV|IX)?)'
          ;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::number -- provide regexes for numbers
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /number/;
  
      while (<>) {
          /^$RE{num}{int}$/                and  print "Integer\n";
          /^$RE{num}{real}$/               and  print "Real\n";
          /^$RE{num}{real}{-base => 16}$/  and  print "Hexadecimal real\n";
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 C<$RE{num}{int}{-base}{-sep}{-group}{-places}>
  
  Returns a pattern that matches an integer.
  
  If C<< -base => I<B> >> is specified, the integer is in base I<B>, with
  C<< 2 <= I<B> <= 36 >>. For bases larger than 10, upper case letters
  are used. The default base is 10.
  
  If C<< -sep => I<P> >> is specified, the pattern I<P> is required as a
  grouping marker within the number. If this option is not given, no
  grouping marker is used.
  
  If C<< -group => I<N> >> is specified, digits between grouping markers
  must be grouped in sequences of exactly I<N> digits. The default value
  of I<N> is 3.  If C<< -group => I<N,M> >> is specified, digits between
  grouping markers must be grouped in sequences of at least I<N> digits,
  and at most I<M> digits. This option is ignored unless the C<< -sep >>
  option is used.
  
  If C<< -places => I<N> >> is specified, the integer recognized must be
  exactly I<N> digits wide. If C<< -places => I<N,M> >> is specified, the
  integer must be at least I<N> wide, and at most I<M> characters. There
  is no default, which means that integers are unlimited in size. This
  option is ignored if the C<< -sep >> option is used.
  
  For example:
  
   $RE{num}{int}                          # match 1234567
   $RE{num}{int}{-sep=>','}               # match 1,234,567
   $RE{num}{int}{-sep=>',?'}              # match 1234567 or 1,234,567
   $RE{num}{int}{-sep=>'.'}{-group=>4}    # match 1.2345.6789
  
  Under C<-keep> (see L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire number
  
  =item $2
  
  captures the optional sign of the number
  
  =item $3
  
  captures the complete set of digits
  
  =back
  
  =head2 C<$RE{num}{real}{-base}{-radix}{-places}{-sep}{-group}{-expon}>
  
  Returns a pattern that matches a floating-point number.
  
  If C<-base=I<N>> is specified, the number is assumed to be in that base
  (with A..Z representing the digits for 11..36). By default, the base is 10.
  
  If C<-radix=I<P>> is specified, the pattern I<P> is used as the radix point for
  the number (i.e. the "decimal point" in base 10). The default is C<qr/[.]/>.
  
  If C<-places=I<N>> is specified, the number is assumed to have exactly
  I<N> places after the radix point.
  If C<-places=I<M,N>> is specified, the number is assumed to have between
  I<M> and I<N> places after the radix point.
  By default, the number of places is unrestricted.
  
  If C<-sep=I<P>> specified, the pattern I<P> is required as a grouping marker
  within the pre-radix section of the number. By default, no separator is
  allowed.
  
  If C<-group=I<N>> is specified, digits between grouping separators
  must be grouped in sequences of exactly I<N> characters. The default value of
  I<N> is 3.
  
  If C<-expon=I<P>> is specified, the pattern I<P> is used as the exponential
  marker.  The default value of I<P> is C<qr/[Ee]/>.
  
  For example:
  
   $RE{num}{real}                  # matches 123.456 or -0.1234567
   $RE{num}{real}{-places=>2}      # matches 123.45 or -0.12
   $RE{num}{real}{-places=>'0,3'}  # matches 123.456 or 0 or 9.8
   $RE{num}{real}{-sep=>'[,.]?'}   # matches 123,456 or 123.456
   $RE{num}{real}{-base=>3'}       # matches 121.102
  
  Under C<-keep>:
  
  =over 4
  
  =item $1
  
  captures the entire match
  
  =item $2
  
  captures the optional sign of the number
  
  =item $3
  
  captures the complete mantissa
  
  =item $4
  
  captures the whole number portion of the mantissa
  
  =item $5
  
  captures the radix point
  
  =item $6
  
  captures the fractional portion of the mantissa
  
  =item $7
  
  captures the optional exponent marker
  
  =item $8
  
  captures the entire exponent value
  
  =item $9
  
  captures the optional sign of the exponent
  
  =item $10
  
  captures the digits of the exponent
  
  =back
  
  =head2 C<$RE{num}{dec}{-radix}{-places}{-sep}{-group}{-expon}>
  
  A synonym for C<< $RE{num}{real}{-base=>10}{...} >>
  
  =head2 C<$RE{num}{oct}{-radix}{-places}{-sep}{-group}{-expon}>
  
  A synonym for C<< $RE{num}{real}{-base=>8}{...} >>
  
  =head2 C<$RE{num}{bin}{-radix}{-places}{-sep}{-group}{-expon}>
  
  A synonym for C<< $RE{num}{real}{-base=>2}{...} >>
  
  =head2 C<$RE{num}{hex}{-radix}{-places}{-sep}{-group}{-expon}>
  
  A synonym for C<< $RE{num}{real}{-base=>16}{...} >>
  
  =head2 C<$RE{num}{decimal}{-base}{-radix}{-places}{-sep}{-group}>
  
  The same as C<$RE{num}{real}>, except that an exponent isn't allowed.
  Hence, this returns a pattern matching I<decimal> numbers.
  
  If C<-base=I<N>> is specified, the number is assumed to be in that base
  (with A..Z representing the digits for 11..36). By default, the base is 10.
  
  If C<-radix=I<P>> is specified, the pattern I<P> is used as the radix point for
  the number (i.e. the "decimal point" in base 10). The default is C<qr/[.]/>.
  
  If C<-places=I<N>> is specified, the number is assumed to have exactly
  I<N> places after the radix point.
  If C<-places=I<M,N>> is specified, the number is assumed to have between
  I<M> and I<N> places after the radix point.
  By default, the number of places is unrestricted.
  
  If C<-sep=I<P>> specified, the pattern I<P> is required as a grouping marker
  within the pre-radix section of the number. By default, no separator is
  allowed.
  
  If C<-group=I<N>> is specified, digits between grouping separators
  must be grouped in sequences of exactly I<N> characters. The default value of
  I<N> is 3.
  
  For example:
  
   $RE{num}{decimal}                  # matches 123.456 or -0.1234567
   $RE{num}{decimal}{-places=>2}      # matches 123.45 or -0.12
   $RE{num}{decimal}{-places=>'0,3'}  # matches 123.456 or 0 or 9.8
   $RE{num}{decimal}{-sep=>'[,.]?'}   # matches 123,456 or 123.456
   $RE{num}{decimal}{-base=>3'}       # matches 121.102
  
  Under C<-keep>:
  
  =over 4
  
  =item $1
  
  captures the entire match
  
  =item $2
  
  captures the optional sign of the number
  
  =item $3
  
  captures the complete mantissa
  
  =item $4
  
  captures the whole number portion of the mantissa
  
  =item $5
  
  captures the radix point
  
  =item $6
  
  captures the fractional portion of the mantissa
  
  =back
  
  =head2 C<$RE{num}{square}>
  
  Returns a pattern that matches a (decimal) square. Because Perl's
  arithmetic is lossy when using integers over about 53 bits, this pattern
  only recognizes numbers less than 9000000000000000, if one uses a
  Perl that is configured to use 64 bit integers. Otherwise, the limit
  is 2147483647. These restrictions were introduced in versions 2.116
  and 2.117 of Regexp::Common. Regardless whether C<-keep> was set,
  the matched number will be returned in C<$1>.
  
  This pattern is available for version 5.008 and up.
  
  =head2 C<$RE{num}{roman}>
  
  Returns a pattern that matches an integer written in Roman numbers.
  Case doesn't matter. Only the more modern style, that is, no more
  than three repetitions of a letter, is recognized. The largest number
  matched is I<MMMCMXCIX>, or 3999. Larger numbers cannot be expressed
  using ASCII characters. A future version will be able to deal with 
  the Unicode symbols to match larger Roman numbers.
  
  Under C<-keep>, the number will be captured in $1.
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_NUMBER

$fatpacked{"Regexp/Common/profanity.pm"} = <<'REGEXP_COMMON_PROFANITY';
  package Regexp::Common::profanity;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  my $profanity = '(?:cvff(?:\\ gnxr|\\-gnxr|gnxr|r(?:ef|[feq])|vat|l)?|dhvzf?|fuvg(?:g(?:r(?:ef|[qe])|vat|l)|r(?:ef|[fqel])|vat|[fr])?|g(?:heqf?|jngf?)|jnax(?:r(?:ef|[eq])|vat|f)?|n(?:ef(?:r(?:\\ ubyr|\\-ubyr|ubyr|[fq])|vat|r)|ff(?:\\ ubyrf?|\\-ubyrf?|rq|ubyrf?|vat))|o(?:hyy(?:\\ fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|\\-fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?)|ybj(?:\\ wbof?|\\-wbof?|wbof?))|p(?:bpx(?:\\ fhpx(?:ref?|vat)|\\-fhpx(?:ref?|vat)|fhpx(?:ref?|vat))|enc(?:c(?:r(?:ef|[eq])|vat|l)|f)?|h(?:agf?|z(?:vat|zvat|f)))|qvpx(?:\\ urnq|\\-urnq|rq|urnq|vat|yrff|f)|s(?:hpx(?:rq|vat|f)?|neg(?:r[eq]|vat|[fl])?|rygpu(?:r(?:ef|[efq])|vat)?)|un(?:eq[\\-\\ ]?ba|ys(?:\\ n[fe]|\\-n[fe]|n[fe])frq)|z(?:bgure(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat))|hgu(?:n(?:\\ shpx(?:ref?|vat|[nnn])|\\-shpx(?:ref?|vat|[nnn])|shpx(?:ref?|vat|[nnn]))|re(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat)))|reqr?))';
  
  my $contextual = '(?:c(?:bex|e(?:bax|vpxf?)|hff(?:vrf|l)|vff(?:\\ gnxr|\\-gnxr|gnxr|r(?:ef|[feq])|vat|l)?)|dhvzf?|ebbg(?:r(?:ef|[eq])|vat|f)?|f(?:bq(?:q(?:rq|vat)|f)?|chax|perj(?:rq|vat|f)?|u(?:nt(?:t(?:r(?:ef|[qe])|vat)|f)?|vg(?:g(?:r(?:ef|[qe])|vat|l)|r(?:ef|[fqel])|vat|[fr])?))|g(?:heqf?|jngf?|vgf?)|jnax(?:r(?:ef|[eq])|vat|f)?|n(?:ef(?:r(?:\\ ubyr|\\-ubyr|ubyr|[fq])|vat|r)|ff(?:\\ ubyrf?|\\-ubyrf?|rq|ubyrf?|vat))|o(?:ba(?:r(?:ef|[fe])|vat|r)|h(?:ttre|yy(?:\\ fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|\\-fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?|fuvg(?:g(?:r(?:ef|[qe])|vat)|f)?))|n(?:fgneq|yy(?:r(?:ef|[qe])|vat|f)?)|yb(?:bql|j(?:\\ wbof?|\\-wbof?|wbof?)))|p(?:bpx(?:\\ fhpx(?:ref?|vat)|\\-fhpx(?:ref?|vat)|fhpx(?:ref?|vat)|f)?|enc(?:c(?:r(?:ef|[eq])|vat|l)|f)?|h(?:agf?|z(?:vat|zvat|f)))|q(?:batf?|vpx(?:\\ urnq|\\-urnq|rq|urnq|vat|yrff|f)?)|s(?:hpx(?:rq|vat|f)?|neg(?:r[eq]|vat|[fl])?|rygpu(?:r(?:ef|[efq])|vat)?)|u(?:hzc(?:r(?:ef|[eq])|vat|f)?|n(?:eq[\\-\\ ]?ba|ys(?:\\ n[fe]|\\-n[fe]|n[fe])frq))|z(?:bgure(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat))|hgu(?:n(?:\\ shpx(?:ref?|vat|[nnn])|\\-shpx(?:ref?|vat|[nnn])|shpx(?:ref?|vat|[nnn]))|re(?:\\ shpx(?:ref?|vat)|\\-shpx(?:ref?|vat)|shpx(?:ref?|vat)))|reqr?))';
  
  tr/A-Za-z/N-ZA-Mn-za-m/ foreach $profanity, $contextual;
  
  pattern name   => [qw (profanity)],
          create => '(?:\b(?k:' . $profanity . ')\b)',
          ;
  
  pattern name   => [qw (profanity contextual)],
          create => '(?:\b(?k:' . $contextual . ')\b)',
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::profanity -- provide regexes for profanity
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /profanity/;
  
      while (<>) {
          /$RE{profanity}/               and  print "Contains profanity\n";
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  =head2 $RE{profanity}
  
  Returns a pattern matching words -- such as Carlin's "big seven" -- that
  are most likely to give offense. Note that correct anatomical terms are
  deliberately I<not> included in the list.
  
  Under C<-keep> (see L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire word
  
  =back
  
  =head2 C<$RE{profanity}{contextual}>
  
  Returns a pattern matching words that are likely to give offense when
  used in specific contexts, but which also have genuinely
  non-offensive meanings.
  
  Under C<-keep> (see L<Regexp::Common>):
  
  =over 4
  
  =item $1
  
  captures the entire word
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_PROFANITY

$fatpacked{"Regexp/Common/whitespace.pm"} = <<'REGEXP_COMMON_WHITESPACE';
  package Regexp::Common::whitespace;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  pattern name   => [qw (ws crop)],
          create => '(?:^\s+|\s+$)',
          subs   => sub {$_[1] =~ s/^\s+//; $_[1] =~ s/\s+$//;}
          ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::whitespace -- provides a regex for leading or
  trailing whitescape
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /whitespace/;
  
      while (<>) {
          s/$RE{ws}{crop}//g;           # Delete surrounding whitespace
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  
  =head2 C<$RE{ws}{crop}>
  
  Returns a pattern that identifies leading or trailing whitespace.
  
  For example:
  
          $str =~ s/$RE{ws}{crop}//g;     # Delete surrounding whitespace
  
  The call:
  
          $RE{ws}{crop}->subs($str);
  
  is optimized (but probably still slower than doing the s///g explicitly).
  
  This pattern does not capture under C<-keep>.
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =head1 AUTHOR
  
  Damian Conway (damian@conway.org)
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Bound to be plenty.
  
  For a start, there are many common regexes missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_WHITESPACE

$fatpacked{"Regexp/Common/zip.pm"} = <<'REGEXP_COMMON_ZIP';
  package Regexp::Common::zip;
  
  use Regexp::Common qw /pattern clean no_defaults/;
  
  use strict;
  use warnings;
  
  use vars qw /$VERSION/;
  $VERSION = '2010010201';
  
  
  #
  # Prefer '[0-9]' over \d, because the latter may include more
  # in Unicode string.
  #
  
  my %code = (
      Australia         =>  [qw /AUS? AU AUS/],
      Belgium           =>  [qw /BE?  BE B/],
      Denmark           =>  [qw /DK   DK DK/],
      France            =>  [qw /FR?  FR F/],
      Germany           =>  [qw /DE?  DE D/],
      Greenland         =>  [qw /DK   DK DK/],
      Italy             =>  [qw /IT?  IT I/],
      Netherlands       =>  [qw /NL   NL NL/],
      Norway            =>  [qw /NO?  NO N/],
      Spain             =>  [qw /ES?  ES E/],
      USA               =>  [qw /USA? US USA/],
  );
  
  # Returns the empty string if the argument is undefined, the argument otherwise.
  sub __ {defined $_ [0] ? $_ [0] : ""}
  
  # Used for allowable options. If the value starts with 'y', the option is
  # required ("{1,1}" is returned, if the value starts with 'n', the option
  # is disallowed ("{0,0}" is returned), otherwise, the option is allowed,
  # but not required ("{0,1}" is returned).
  sub _t {
      if (defined $_ [0]) {
          if ($_ [0] =~ /^y/i) {return "{1,1}"}
          if ($_ [0] =~ /^n/i) {return "{0,0}"}
      }
      "{0,1}"
  }
  
  # Returns the (sub)pattern for the country named '$name', and the 
  # -country option '$country'.
  sub _c {
      my ($name, $country) = @_;
      if (defined $country && $country ne "") {
          if ($country eq 'iso')  {return $code {$name} [1]}
          if ($country eq 'cept') {return $code {$name} [2]}
          return $country;
      }
      $code {$name} [0]
  }
  
  
  my %zip = (
      Australia   =>  "(?k:(?k:[1-8][0-9]|9[0-7]|0?[28]|0?9(?=09))(?k:[0-9]{2}))",
                      # Postal codes of the form 'DDDD', with the first
                      # two digits 02, 08 or 20-97. Leading 0 may be omitted.
                      # 909 and 0909 are valid as well - but no other postal
                      # codes starting with 9 or 09.
  
      Belgium     =>  "(?k:(?k:[1-9])(?k:[0-9]{3}))",
                      # Postal codes of the form: 'DDDD', with the first
                      # digit representing the province; the others
                      # distribution sectors. Postal codes do not start
                      # with a zero.
  
      Denmark     =>  "(?k:(?k:[1-9])(?k:[0-9])(?k:[0-9]{2}))",
                      # Postal codes of the form: 'DDDD', with the first
                      # digit representing the distribution region, the
                      # second digit the distribution district. Postal
                      # codes do not start with a zero. Postal codes 
                      # starting with '39' are in Greenland.
  
      France      =>  "(?k:(?k:[0-8][0-9]|9[0-8])(?k:[0-9]{3}))",
                      # Postal codes of the form: 'DDDDD'. All digits are used.
                      # First two digits indicate the department, and range
                      # from 01 to 98, or 00 for army.
  
      Germany     =>  "(?k:(?k:[0-9])(?k:[0-9])(?k:[0-9]{3}))",
                      # Postal codes of the form: 'DDDDD'. All digits are used.
                      # First digit is the distribution zone, second a
                      # distribution region. Other digits indicate the
                      # distribution district and postal town.
  
      Greenland   =>  "(?k:(?k:39)(?k:[0-9]{2}))",
                      # Postal codes of Greenland are part of the Danish
                      # system. Codes in Greenland start with 39.
  
      Italy       =>  "(?k:(?k:[0-9])(?k:[0-9])(?k:[0-9])(?k:[0-9])(?k:[0-9]))",
                      # First digit: region.
                      # Second digit: province.
                      # Third digit: capital/province (odd for capital).
                      # Fourth digit: route.
                      # Fifth digit: place on route (0 for small places)
  
      Norway      =>  "(?k:[0-9]{4})",
                      # Four digits, no significance (??).
  
      Spain       =>  "(?k:(?k:0[1-9]|[1-4][0-9]|5[0-2])(?k:[0-9])(?k:[0-9]{2}))",
                      # Five digits, first two indicate the province.
                      # Third digit: large town, main delivery rounds.
                      # Last 2 digits: delivery area, secondary delivery route
                      #                or link to rural areas.
  
      Switzerland =>  "(?k:[1-9][0-9]{3})",
                      # Four digits, first is district, second is area,
                      # third is route, fourth is post office number.
  );
  
  my %alternatives = (
      Australia    => [qw /Australian/],
      France       => [qw /French/],
      Germany      => [qw /German/],
  );
  
  
  while (my ($country, $zip) = each %zip) {
      my @names = ($country);
      push @names => @{$alternatives {$country}} if $alternatives {$country};
      foreach my $name (@names) {
          my $pat_name = $name eq "Denmark" && $] < 5.00503
                         ?   [zip => $name, qw /-country=/]
                         :   [zip => $name, qw /-prefix= -country=/];
          pattern name    => $pat_name,
                  create  => sub {
                      my $pt  = _t $_ [1] {-prefix};
  
                      my $cn  = _c $country => $_ [1] {-country};
                      my $pfx = "(?:(?k:$cn)-)";
  
                      "(?k:$pfx$pt$zip)";
                  },
                  ;
      }
  }
  
  
  # Postal codes of the form 'DDDD LL', with F, I, O, Q, U and Y not
  # used, SA, SD and SS unused combinations, and the first digit
  # cannot be 0. No specific meaning to the letters or digits.
  foreach my $country (qw /Netherlands Dutch/) {
      pattern name   => ['zip', $country => qw /-prefix= -country=/, "-sep= "],
              create => sub {
                  my $pt  = _t $_ [1] {-prefix};
  
                  # Unused letters: F, I, O, Q, U, Y.
                  # Unused combinations: SA, SD, SS.
                  my $num =  '[1-9][0-9]{3}';
                  my $let =  '[A-EGHJ-NPRTVWXZ][A-EGHJ-NPRSTVWXZ]|' .
                             'S[BCEGHJ-NPRTVWXZ]';
  
                  my $sep = __ $_ [1] {-sep};
                  my $cn  = _c Netherlands => $_ [1] {-country};
                  my $pfx = "(?:(?k:$cn)-)";
  
                  "(?k:$pfx$pt(?k:(?k:$num)(?k:$sep)(?k:$let)))";
              },
              ;
  }
  
  
  # Postal codes of the form 'DDDDD' or 'DDDDD-DDDD'. All digits are used,
  # none carry any specific meaning.
  pattern name    => [qw /zip US -prefix= -country= -extended= -sep=-/],
          create  => sub {
              my $pt  = _t $_ [1] {-prefix};
              my $et  = _t $_ [1] {-extended};
  
              my $sep = __ $_ [1] {-sep};
  
              my $cn  = _c USA => $_ [1] {-country};
              my $pfx = "(?:(?k:$cn)-)";
              # my $zip = "(?k:[0-9]{5})";
              # my $ext = "(?:(?k:$sep)(?k:[0-9]{4}))";
              my $zip = "(?k:(?k:[0-9]{3})(?k:[0-9]{2}))";
              my $ext = "(?:(?k:$sep)(?k:(?k:[0-9]{2})(?k:[0-9]{2})))";
  
              "(?k:$pfx$pt(?k:$zip$ext$et))";
          },
          version => 5.00503,
          ;
  
  
  # pattern name   => [qw /zip British/, "-sep= "],
  #         create => sub {
  #             my $sep     = $_ [1] -> {-sep};
  # 
  #             my $london  = '(?:EC[1-4]|WC[12]|S?W1)[A-Z]';
  #             my $single  = '[BGLMS][0-9]{1,2}';
  #             my $double  = '[A-Z]{2}[0-9]{1,2}';
  # 
  #             my $left    = "(?:$london|$single|$double)";
  #             my $right   = '[0-9][ABD-HJLNP-UW-Z]{2}';
  # 
  #             "(?k:(?k:$left)(?k:$sep)(?k:$right))";
  #         },
  #         ;
  # 
  # pattern name   => [qw /zip Canadian/, "-sep= "],
  #         create => sub {
  #             my $sep     = $_ [1] -> {-sep};
  # 
  #             my $left    = '[A-Z][0-9][A-Z]';
  #             my $right   = '[0-9][A-Z][0-9]';
  # 
  #             "(?k:(?k:$left)(?k:$sep)(?k:$right))";
  #         },
  #         ;
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Regexp::Common::zip -- provide regexes for postal codes.
  
  =head1 SYNOPSIS
  
      use Regexp::Common qw /zip/;
  
      while (<>) {
          /^$RE{zip}{Netherlands}$/   and  print "Dutch postal code\n";
      }
  
  
  =head1 DESCRIPTION
  
  Please consult the manual of L<Regexp::Common> for a general description
  of the works of this interface.
  
  Do not use this module directly, but load it via I<Regexp::Common>.
  
  This module offers patterns for zip or postal codes of many different
  countries. They all have the form C<$RE{zip}{Country}[{options}]>.
  
  The following common options are used:
  
  =head2 C<{-prefix=[yes|no|allow]}> and C<{-country=PAT}>.
  
  Postal codes can be prefixed with a country abbreviation. That is,
  a dutch postal code of B<1234 AB> can also be written as B<NL-1234 AB>.
  By default, all the patterns will allow the prefixes. But this can be
  changed with the C<-prefix> option. With C<-prefix=yes>, the returned
  pattern requires a country prefix, while C<-prefix=no> disallows a
  prefix. Any argument that doesn't start with a C<y> or a C<n> allows a
  country prefix, but doesn't require them.
  
  The prefixes used are, unfortunally, not always the same. Officially,
  ISO country codes need to be used, but the usage of I<CEPT> codes (the
  same ones as used on cars) is common too. By default, each postal code
  will recognize a country prefix that's either the ISO standard or the
  CEPT code. That is, German postal codes may prefixed with either C<DE>
  or C<D>. The recognized prefix can be changed with the C<-country>
  option, which takes a (sub)pattern as argument. The arguments C<iso>
  and C<cept> are special, and indicate the language prefix should be the
  ISO country code, or the CEPT code.
  
  Examples:
   /$RE{zip}{Netherlands}/;
             # Matches '1234 AB' and 'NL-1234 AB'.
   /$RE{zip}{Netherlands}{-prefix => 'no'}/;
             # Matches '1234 AB' but not 'NL-1234 AB'.
   /$RE{zip}{Netherlands}{-prefix => 'yes'}/;
             # Matches 'NL-1234 AB' but not '1234 AB'.
  
   /$RE{zip}{Germany}/;
             # Matches 'DE-12345' and 'D-12345'.
   /$RE{zip}{Germany}{-country => 'iso'}/; 
             # Matches 'DE-12345' but not 'D-12345'.
   /$RE{zip}{Germany}{-country => 'cept'}/;
             # Matches 'D-12345' but not 'DE-12345'.
   /$RE{zip}{Germany}{-country => 'GER'}/;
             # Matches 'GER-12345'.
  
  =head2 C<{-sep=PAT}>
  
  Some countries have postal codes that consist of two parts. Typically
  there is an official way of separating those parts; but in practise
  people tend to use different separators. For instance, if the official
  way to separate parts is to use a space, it happens that the space is
  left off. The C<-sep> option can be given a pattern as argument which
  indicates what to use as a separator between the parts.
  
  Examples:
   /$RE{zip}{Netherlands}/;
             # Matches '1234 AB' but not '1234AB'.
   /$RE{zip}{Netherlands}{-sep => '\s*'}/;
             # Matches '1234 AB' and '1234AB'.
  
  =head2 C<$RE{zip}{Australia}>
  
  Returns a pattern that recognizes Australian postal codes. Australian
  postal codes consist of four digits; the first two digits, which range
  from '10' to '97', indicate the state. Territories use '02' or '08'
  as starting digits; the leading zero is optional. '0909' is the only 
  postal code starting with '09' (the leading zero is optional here as
  well) - this is the postal code for the Nothern Territory University).
  The (optional) country
  prefixes are I<AU> (ISO country code) and I<AUS> (CEPT code).
  Regexp::Common 2.107 and before used C<$RE{zip}{Australia}>. This is
  still supported.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The state or territory.
  
  =item $5
  
  The last two digits.
  
  =back
  
  =head2 C<$RE{zip}{Belgium}>
  
  Returns a pattern than recognizes Belgian postal codes. Belgian postal
  codes consist of 4 digits, of which the first indicates the province.
  The (optional) country prefixes are I<BE> (ISO country code) and
  I<B> (CEPT code).
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The digit indicating the province.
  
  =item $5
  
  The last three digits of the postal code.
  
  =back
  
  
  =head2 C<$RE{zip}{Denmark}>
  
  Returns a pattern that recognizes Danish postal codes. Danish postal
  codes consist of four numbers; the first digit (which cannot be 0),
  indicates the distribution region, the second the distribution
  district. The (optional) country prefix is I<DK>, which is both
  the ISO country code and the CEPT code.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The digit indicating the distribution region.
  
  =item $5
  
  The digit indicating the distribution district.
  
  =item $6
  
  The last two digits of the postal code.
  
  =back
  
  
  =head2 C<$RE{zip}{France}>
  
  Returns a pattern that recognizes French postal codes. French postal
  codes consist of five numbers; the first two numbers, which range
  from '01' to '98', indicate the department. The (optional) country
  prefixes are I<FR> (ISO country code) and I<F> (CEPT code).
  Regexp::Common 2.107 and before used C<$RE{zip}{French}>. This is
  still supported.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The department.
  
  =item $5
  
  The last three digits.
  
  =back
  
  =head2 C<$RE{zip}{Germany}>
  
  Returns a pattern that recognizes German postal codes. German postal
  codes consist of five numbers; the first number indicating the
  distribution zone, the second the distribution region, while the 
  latter three indicate the distribution district and the postal town.
  The (optional) country prefixes are I<DE> (ISO country code) and
  I<D> (CEPT code).
  Regexp::Common 2.107 and before used C<$RE{zip}{German}>. This is
  still supported.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The distribution zone.
  
  =item $5
  
  The distribution region.
  
  =item $6
  
  The distribution district and postal town.
  
  =back
  
  
  =head2 C<$RE{zip}{Greenland}>
  
  Returns a pattern that recognizes postal codes from Greenland.
  Greenland, being part of Denmark, uses Danish postal codes.
  All postal codes of Greenland start with 39.
  The (optional) country prefix is I<DK>, which is both
  the ISO country code and the CEPT code.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  39, being the distribution region and distribution district for Greenland.
  
  =item $5
  
  The last two digits of the postal code.
  
  =back
  
  =head2 C<$RE{zip}{Italy}>
  
  Returns a pattern recognizing Italian postal codes. Italian postal
  codes consist of 5 digits. The first digit indicates the region, the
  second the province. The third digit is odd for province capitals,
  and even for the province itself. The fourth digit indicates the
  route, and the fifth a place on the route (0 for small places, 
  alphabetically for the rest).
  
  The country prefix is either I<IT> (the ISO country code), or
  I<I> (the CEPT code).
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The region.
  
  =item $5
  
  The province.
  
  =item $6 
  
  Capital or province.
  
  =item $7
  
  The route.
  
  =item $8
  
  The place on the route.
  
  =back
  
  =head2 C<$RE{zip}{Netherlands}>
  
  Returns a pattern that recognizes Dutch postal codes. Dutch postal
  codes consist of 4 digits and 2 letters, separated by a space.
  The separator can be changed using the C<{-sep}> option, as discussed
  above. The (optional) country prefix is I<NL>, which is both the 
  ISO country code and the CEPT code. Regexp::Common 2.107 and earlier
  used C<$RE{zip}{Dutch}>. This is still supported.
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The digits part of the postal code.
  
  =item $5
  
  The separator between the digits and the letters.
  
  =item $6 
  
  The letters part of the postal code.
  
  =back
  
  =head2 C<< $RE{zip}{Norway} >>
  
  Returns a pattern that recognizes Norwegian postal codes. Norwegian
  postal codes consist of four digits.
  
  The country prefix is either I<NO> (the ISO country code), or
  I<N> (the CEPT code).
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =back
  
  =head2 C<< $RE{zip}{Spain} >>
  
  Returns a pattern that recognizes Spanish postal codes. Spanish postal
  codes consist of 5 digits. The first 2 indicate one of Spains fifties
  provinces (in alphabetical order), starting with C<00>. The third digit
  indicates a main city or the main delivery rounds. The last two digits
  are the delivery area, secondary delivery route or a link to rural areas.
  
  The country prefix is either I<ES> (the ISO country code), or
  I<E> (the CEPT code).
  
  If C<{-keep}> is used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The two digits indicating the province.
  
  =item $5
  
  The digit indicating the main city or main delivery route.
  
  =item $6
  
  The digits indicating the delivery area, secondary delivery route
  or a link to rural areas.
  
  =back
  
  =head2 C<< $RE{zip}{Switzerland} >>
  
  Returns a pattern that recognizes Swiss postal codes. Swiss postal
  codes consist of 4 digits. The first indicates the district, starting
  with 1. The second indicates the area, the third, the route, and the
  fourth the post office number.
  
  =head2 C<< $RE{zip}{US}{-extended => [yes|no|allow]} >>
  
  Returns a pattern that recognizes US zip codes. US zip codes consist
  of 5 digits, with an optional 4 digit extension. By default, extensions
  are allowed, but not required. This can be influenced by the 
  C<-extended> option. If its argument starts with a C<y>,
  extensions are required; if the argument starts with a C<n>,
  extensions will not be recognized. If an extension is used, a dash
  is used to separate the main part from the extension, but this can
  be changed with the C<-sep> option.
  
  The country prefix is either I<US> (the ISO country code), or
  I<USA> (the CEPT code).
  
  If C<{-keep}> is being used, the following variables will be set:
  
  =over 4
  
  =item $1
  
  The entire postal code.
  
  =item $2
  
  The country code prefix.
  
  =item $3
  
  The postal code without the country prefix.
  
  =item $4
  
  The first 5 digits of the postal code.
  
  =item $5
  
  The first three digits of the postal code, indicating a sectional
  center or a large city. New in Regexp::Common 2.119.
  
  =item $6
  
  The last 2 digits of the 5 digit part of the postal code, indicating
  a post office facility or delivery area. New in Regexp::Common 2.119.
  
  =item $7
  
  The separator between the 5 digit part and the 4 digit part. Up to 
  Regexp::Common 2.118, this used to be $5.
  
  =item $8
  
  The 4 digit part of the postal code (if any). Up to Regexp::Common 2.118,
  this used to be $6.
  
  =item $9
  
  The first two digits of the 4 digit part of the postal code, indicating
  a sector, or several blocks. New in Regexp::Common 2.119.
  
  =item $10
  
  The last two digits of the 4 digit part of the postal code, indicating
  a segment or one side of a street. New in Regexp::Common 2.119.
  
  =back
  
  You need at least version 5.005_03 to be able to use US postal codes.
  Older versions contain a bug that let the pattern match invalid US
  postal codes.
  
  =head3 Questions
  
  =over 4
  
  =item
  
  Can the 5 digit part of the zip code (in theory) start with 000?
  
  =item
  
  Can the 5 digit part of the zip code (in theory) end with 00?
  
  =item
  
  Can the 4 digit part of the zip code (in theory) start with 00?
  
  =item
  
  Can the 4 digit part of the zip code (in theory) end with 00?
  
  =back
  
  =head1 SEE ALSO
  
  L<Regexp::Common> for a general description of how to use this interface.
  
  =over 4
  
  =item L<http://www.columbia.edu/kermit/postal.html>
  
  Frank's compulsive guide to postal addresses.
  
  =item L<http://www.upu.int/post_code/en/addressing_formats_guide.shtml>
  
  Postal addressing systems.
  
  =item L<http://www.uni-koeln.de/~arcd2/33e.htm>
  
  Postal code information.
  
  =item L<http://www.grcdi.nl/linkspc.htm>
  
  Links to Postcode Pages.
  
  =item L<http://www1.auspost.com.au/postcodes/>
  
  Information about Australian postal codes.
  
  =item L<http://hdusps.esecurecare.net/cgi-bin/hdusps.cfg/php/enduser/std_adp.php?p_faqid=1014>
  
  Information about US postal codes.
  
  =item L<http://en.wikipedia.org/wiki/Postal_code>
  
  =back
  
  =head1 AUTHORS
  
  Damian Conway S<(I<damian@conway.org>)> and
  Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 MAINTAINANCE
  
  This package is maintained by Abigail S<(I<regexp-common@abigail.be>)>.
  
  =head1 BUGS AND IRRITATIONS
  
  Zip codes for most countries are missing.
  Send them in to I<regexp-common@abigail.be>.
  
  =head1 LICENSE and COPYRIGHT
  
  This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.
  
  This module is free software, and maybe used under any of the following
  licenses:
  
   1) The Perl Artistic License.     See the file COPYRIGHT.AL.
   2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
   3) The BSD Licence.               See the file COPYRIGHT.BSD.
   4) The MIT Licence.               See the file COPYRIGHT.MIT.
  
  =cut
REGEXP_COMMON_ZIP

$fatpacked{"i386-linux-thread-multi/Data/Dumper.pm"} = <<'I386-LINUX-THREAD-MULTI_DATA_DUMPER';
  #
  # Data/Dumper.pm
  #
  # convert perl data structures into perl syntax suitable for both printing
  # and eval
  #
  # Documentation at the __END__
  #
  
  package Data::Dumper;
  
  $VERSION = '2.125'; # Don't forget to set version and release date in POD!
  
  #$| = 1;
  
  use 5.006_001;
  require Exporter;
  require overload;
  
  use Carp;
  
  BEGIN {
      @ISA = qw(Exporter);
      @EXPORT = qw(Dumper);
      @EXPORT_OK = qw(DumperX);
  
      # if run under miniperl, or otherwise lacking dynamic loading,
      # XSLoader should be attempted to load, or the pure perl flag
      # toggled on load failure.
      eval {
  	require XSLoader;
      };
      $Useperl = 1 if $@;
  }
  
  XSLoader::load( 'Data::Dumper' ) unless $Useperl;
  
  # module vars and their defaults
  $Indent     = 2         unless defined $Indent;
  $Purity     = 0         unless defined $Purity;
  $Pad        = ""        unless defined $Pad;
  $Varname    = "VAR"     unless defined $Varname;
  $Useqq      = 0         unless defined $Useqq;
  $Terse      = 0         unless defined $Terse;
  $Freezer    = ""        unless defined $Freezer;
  $Toaster    = ""        unless defined $Toaster;
  $Deepcopy   = 0         unless defined $Deepcopy;
  $Quotekeys  = 1         unless defined $Quotekeys;
  $Bless      = "bless"   unless defined $Bless;
  #$Expdepth   = 0         unless defined $Expdepth;
  $Maxdepth   = 0         unless defined $Maxdepth;
  $Pair       = ' => '    unless defined $Pair;
  $Useperl    = 0         unless defined $Useperl;
  $Sortkeys   = 0         unless defined $Sortkeys;
  $Deparse    = 0         unless defined $Deparse;
  
  #
  # expects an arrayref of values to be dumped.
  # can optionally pass an arrayref of names for the values.
  # names must have leading $ sign stripped. begin the name with *
  # to cause output of arrays and hashes rather than refs.
  #
  sub new {
    my($c, $v, $n) = @_;
  
    croak "Usage:  PACKAGE->new(ARRAYREF, [ARRAYREF])" 
      unless (defined($v) && (ref($v) eq 'ARRAY'));
    $n = [] unless (defined($n) && (ref($n) eq 'ARRAY'));
  
    my($s) = { 
               level      => 0,           # current recursive depth
  	     indent     => $Indent,     # various styles of indenting
  	     pad	=> $Pad,        # all lines prefixed by this string
  	     xpad       => "",          # padding-per-level
  	     apad       => "",          # added padding for hash keys n such
  	     sep        => "",          # list separator
  	     pair	=> $Pair,	# hash key/value separator: defaults to ' => '
  	     seen       => {},          # local (nested) refs (id => [name, val])
  	     todump     => $v,          # values to dump []
  	     names      => $n,          # optional names for values []
  	     varname    => $Varname,    # prefix to use for tagging nameless ones
               purity     => $Purity,     # degree to which output is evalable
               useqq 	=> $Useqq,      # use "" for strings (backslashitis ensues)
               terse 	=> $Terse,      # avoid name output (where feasible)
               freezer	=> $Freezer,    # name of Freezer method for objects
               toaster	=> $Toaster,    # name of method to revive objects
               deepcopy	=> $Deepcopy,   # dont cross-ref, except to stop recursion
               quotekeys	=> $Quotekeys,  # quote hash keys
               'bless'	=> $Bless,	# keyword to use for "bless"
  #	     expdepth   => $Expdepth,   # cutoff depth for explicit dumping
  	     maxdepth	=> $Maxdepth,   # depth beyond which we give up
  	     useperl    => $Useperl,    # use the pure Perl implementation
  	     sortkeys   => $Sortkeys,   # flag or filter for sorting hash keys
  	     deparse	=> $Deparse,	# use B::Deparse for coderefs
  	   };
  
    if ($Indent > 0) {
      $s->{xpad} = "  ";
      $s->{sep} = "\n";
    }
    return bless($s, $c);
  }
  
  if ($] >= 5.008) {
    # Packed numeric addresses take less memory. Plus pack is faster than sprintf
    *init_refaddr_format = sub {};
  
    *format_refaddr  = sub {
      require Scalar::Util;
      pack "J", Scalar::Util::refaddr(shift);
    };
  } else {
    *init_refaddr_format = sub {
      require Config;
      my $f = $Config::Config{uvxformat};
      $f =~ tr/"//d;
      our $refaddr_format = "0x%" . $f;
    };
  
    *format_refaddr = sub {
      require Scalar::Util;
      sprintf our $refaddr_format, Scalar::Util::refaddr(shift);
    }
  }
  
  #
  # add-to or query the table of already seen references
  #
  sub Seen {
    my($s, $g) = @_;
    if (defined($g) && (ref($g) eq 'HASH'))  {
      init_refaddr_format();
      my($k, $v, $id);
      while (($k, $v) = each %$g) {
        if (defined $v and ref $v) {
  	$id = format_refaddr($v);
  	if ($k =~ /^[*](.*)$/) {
  	  $k = (ref $v eq 'ARRAY') ? ( "\\\@" . $1 ) :
  	       (ref $v eq 'HASH')  ? ( "\\\%" . $1 ) :
  	       (ref $v eq 'CODE')  ? ( "\\\&" . $1 ) :
  				     (   "\$" . $1 ) ;
  	}
  	elsif ($k !~ /^\$/) {
  	  $k = "\$" . $k;
  	}
  	$s->{seen}{$id} = [$k, $v];
        }
        else {
  	carp "Only refs supported, ignoring non-ref item \$$k";
        }
      }
      return $s;
    }
    else {
      return map { @$_ } values %{$s->{seen}};
    }
  }
  
  #
  # set or query the values to be dumped
  #
  sub Values {
    my($s, $v) = @_;
    if (defined($v) && (ref($v) eq 'ARRAY'))  {
      $s->{todump} = [@$v];        # make a copy
      return $s;
    }
    else {
      return @{$s->{todump}};
    }
  }
  
  #
  # set or query the names of the values to be dumped
  #
  sub Names {
    my($s, $n) = @_;
    if (defined($n) && (ref($n) eq 'ARRAY'))  {
      $s->{names} = [@$n];         # make a copy
      return $s;
    }
    else {
      return @{$s->{names}};
    }
  }
  
  sub DESTROY {}
  
  sub Dump {
      return &Dumpxs
  	unless $Data::Dumper::Useperl || (ref($_[0]) && $_[0]->{useperl}) ||
  	       $Data::Dumper::Useqq   || (ref($_[0]) && $_[0]->{useqq}) ||
  	       $Data::Dumper::Deparse || (ref($_[0]) && $_[0]->{deparse});
      return &Dumpperl;
  }
  
  #
  # dump the refs in the current dumper object.
  # expects same args as new() if called via package name.
  #
  sub Dumpperl {
    my($s) = shift;
    my(@out, $val, $name);
    my($i) = 0;
    local(@post);
    init_refaddr_format();
  
    $s = $s->new(@_) unless ref $s;
  
    for $val (@{$s->{todump}}) {
      my $out = "";
      @post = ();
      $name = $s->{names}[$i++];
      if (defined $name) {
        if ($name =~ /^[*](.*)$/) {
  	if (defined $val) {
  	  $name = (ref $val eq 'ARRAY') ? ( "\@" . $1 ) :
  		  (ref $val eq 'HASH')  ? ( "\%" . $1 ) :
  		  (ref $val eq 'CODE')  ? ( "\*" . $1 ) :
  					  ( "\$" . $1 ) ;
  	}
  	else {
  	  $name = "\$" . $1;
  	}
        }
        elsif ($name !~ /^\$/) {
  	$name = "\$" . $name;
        }
      }
      else {
        $name = "\$" . $s->{varname} . $i;
      }
  
      my $valstr;
      {
        local($s->{apad}) = $s->{apad};
        $s->{apad} .= ' ' x (length($name) + 3) if $s->{indent} >= 2;
        $valstr = $s->_dump($val, $name);
      }
  
      $valstr = "$name = " . $valstr . ';' if @post or !$s->{terse};
      $out .= $s->{pad} . $valstr . $s->{sep};
      $out .= $s->{pad} . join(';' . $s->{sep} . $s->{pad}, @post) 
        . ';' . $s->{sep} if @post;
  
      push @out, $out;
    }
    return wantarray ? @out : join('', @out);
  }
  
  # wrap string in single quotes (escaping if needed)
  sub _quote {
      my $val = shift;
      $val =~ s/([\\\'])/\\$1/g;
      return  "'" . $val .  "'";
  }
  
  #
  # twist, toil and turn;
  # and recurse, of course.
  # sometimes sordidly;
  # and curse if no recourse.
  #
  sub _dump {
    my($s, $val, $name) = @_;
    my($sname);
    my($out, $realpack, $realtype, $type, $ipad, $id, $blesspad);
  
    $type = ref $val;
    $out = "";
  
    if ($type) {
  
      # Call the freezer method if it's specified and the object has the
      # method.  Trap errors and warn() instead of die()ing, like the XS
      # implementation.
      my $freezer = $s->{freezer};
      if ($freezer and UNIVERSAL::can($val, $freezer)) {
        eval { $val->$freezer() };
        warn "WARNING(Freezer method call failed): $@" if $@;
      }
  
      require Scalar::Util;
      $realpack = Scalar::Util::blessed($val);
      $realtype = $realpack ? Scalar::Util::reftype($val) : ref $val;
      $id = format_refaddr($val);
  
      # if it has a name, we need to either look it up, or keep a tab
      # on it so we know when we hit it later
      if (defined($name) and length($name)) {
        # keep a tab on it so that we dont fall into recursive pit
        if (exists $s->{seen}{$id}) {
  #	if ($s->{expdepth} < $s->{level}) {
  	  if ($s->{purity} and $s->{level} > 0) {
  	    $out = ($realtype eq 'HASH')  ? '{}' :
  	      ($realtype eq 'ARRAY') ? '[]' :
  		'do{my $o}' ;
  	    push @post, $name . " = " . $s->{seen}{$id}[0];
  	  }
  	  else {
  	    $out = $s->{seen}{$id}[0];
  	    if ($name =~ /^([\@\%])/) {
  	      my $start = $1;
  	      if ($out =~ /^\\$start/) {
  		$out = substr($out, 1);
  	      }
  	      else {
  		$out = $start . '{' . $out . '}';
  	      }
  	    }
            }
  	  return $out;
  #        }
        }
        else {
          # store our name
          $s->{seen}{$id} = [ (($name =~ /^[@%]/)     ? ('\\' . $name ) :
  			     ($realtype eq 'CODE' and
  			      $name =~ /^[*](.*)$/) ? ('\\&' . $1 )   :
  			     $name          ),
  			    $val ];
        }
      }
      my $no_bless = 0; 
      my $is_regex = 0;
      if ( $realpack and ($] >= 5.009005 ? re::is_regexp($val) : $realpack eq 'Regexp') ) {
          $is_regex = 1;
          $no_bless = $realpack eq 'Regexp';
      }
  
      # If purity is not set and maxdepth is set, then check depth: 
      # if we have reached maximum depth, return the string
      # representation of the thing we are currently examining
      # at this depth (i.e., 'Foo=ARRAY(0xdeadbeef)'). 
      if (!$s->{purity}
  	and $s->{maxdepth} > 0
  	and $s->{level} >= $s->{maxdepth})
      {
        return qq['$val'];
      }
  
      # we have a blessed ref
      if ($realpack and !$no_bless) {
        $out = $s->{'bless'} . '( ';
        $blesspad = $s->{apad};
        $s->{apad} .= '       ' if ($s->{indent} >= 2);
      }
  
      $s->{level}++;
      $ipad = $s->{xpad} x $s->{level};
  
      if ($is_regex) {
          my $pat;
          # This really sucks, re:regexp_pattern is in ext/re/re.xs and not in 
          # universal.c, and even worse we cant just require that re to be loaded
          # we *have* to use() it. 
          # We should probably move it to universal.c for 5.10.1 and fix this.
          # Currently we only use re::regexp_pattern when the re is blessed into another
          # package. This has the disadvantage of meaning that a DD dump won't round trip
          # as the pattern will be repeatedly wrapped with the same modifiers.
          # This is an aesthetic issue so we will leave it for now, but we could use
          # regexp_pattern() in list context to get the modifiers separately.
          # But since this means loading the full debugging engine in process we wont
          # bother unless its necessary for accuracy.
          if (($realpack ne 'Regexp') && defined(*re::regexp_pattern{CODE})) {
              $pat = re::regexp_pattern($val);
          } else {
              $pat = "$val";
          }
          $pat =~ s,/,\\/,g;
          $out .= "qr/$pat/";
      }
      elsif ($realtype eq 'SCALAR' || $realtype eq 'REF') {
        if ($realpack) {
  	$out .= 'do{\\(my $o = ' . $s->_dump($$val, "\${$name}") . ')}';
        }
        else {
  	$out .= '\\' . $s->_dump($$val, "\${$name}");
        }
      }
      elsif ($realtype eq 'GLOB') {
  	$out .= '\\' . $s->_dump($$val, "*{$name}");
      }
      elsif ($realtype eq 'ARRAY') {
        my($pad, $mname);
        my($i) = 0;
        $out .= ($name =~ /^\@/) ? '(' : '[';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        ($name =~ /^\@(.*)$/) ? ($mname = "\$" . $1) : 
  	# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
  	($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
  	  ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        for my $v (@$val) {
  	$sname = $mname . '[' . $i . ']';
  	$out .= $pad . $ipad . '#' . $i if $s->{indent} >= 3;
  	$out .= $pad . $ipad . $s->_dump($v, $sname);
  	$out .= "," if $i++ < $#$val;
        }
        $out .= $pad . ($s->{xpad} x ($s->{level} - 1)) if $i;
        $out .= ($name =~ /^\@/) ? ')' : ']';
      }
      elsif ($realtype eq 'HASH') {
        my($k, $v, $pad, $lpad, $mname, $pair);
        $out .= ($name =~ /^\%/) ? '(' : '{';
        $pad = $s->{sep} . $s->{pad} . $s->{apad};
        $lpad = $s->{apad};
        $pair = $s->{pair};
        ($name =~ /^\%(.*)$/) ? ($mname = "\$" . $1) :
  	# omit -> if $foo->[0]->{bar}, but not ${$foo->[0]}->{bar}
  	($name =~ /^\\?[\%\@\*\$][^{].*[]}]$/) ? ($mname = $name) :
  	  ($mname = $name . '->');
        $mname .= '->' if $mname =~ /^\*.+\{[A-Z]+\}$/;
        my ($sortkeys, $keys, $key) = ("$s->{sortkeys}");
        if ($sortkeys) {
  	if (ref($s->{sortkeys}) eq 'CODE') {
  	  $keys = $s->{sortkeys}($val);
  	  unless (ref($keys) eq 'ARRAY') {
  	    carp "Sortkeys subroutine did not return ARRAYREF";
  	    $keys = [];
  	  }
  	}
  	else {
  	  $keys = [ sort keys %$val ];
  	}
        }
  
        # Ensure hash iterator is reset
        keys(%$val);
  
        while (($k, $v) = ! $sortkeys ? (each %$val) :
  	     @$keys ? ($key = shift(@$keys), $val->{$key}) :
  	     () ) 
        {
  	my $nk = $s->_dump($k, "");
  	$nk = $1 if !$s->{quotekeys} and $nk =~ /^[\"\']([A-Za-z_]\w*)[\"\']$/;
  	$sname = $mname . '{' . $nk . '}';
  	$out .= $pad . $ipad . $nk . $pair;
  
  	# temporarily alter apad
  	$s->{apad} .= (" " x (length($nk) + 4)) if $s->{indent} >= 2;
  	$out .= $s->_dump($val->{$k}, $sname) . ",";
  	$s->{apad} = $lpad if $s->{indent} >= 2;
        }
        if (substr($out, -1) eq ',') {
  	chop $out;
  	$out .= $pad . ($s->{xpad} x ($s->{level} - 1));
        }
        $out .= ($name =~ /^\%/) ? ')' : '}';
      }
      elsif ($realtype eq 'CODE') {
        if ($s->{deparse}) {
  	require B::Deparse;
  	my $sub =  'sub ' . (B::Deparse->new)->coderef2text($val);
  	$pad    =  $s->{sep} . $s->{pad} . $s->{apad} . $s->{xpad} x ($s->{level} - 1);
  	$sub    =~ s/\n/$pad/gse;
  	$out   .=  $sub;
        } else {
          $out .= 'sub { "DUMMY" }';
          carp "Encountered CODE ref, using dummy placeholder" if $s->{purity};
        }
      }
      else {
        croak "Can\'t handle $realtype type.";
      }
      
      if ($realpack and !$no_bless) { # we have a blessed ref
        $out .= ', ' . _quote($realpack) . ' )';
        $out .= '->' . $s->{toaster} . '()'  if $s->{toaster} ne '';
        $s->{apad} = $blesspad;
      }
      $s->{level}--;
  
    }
    else {                                 # simple scalar
  
      my $ref = \$_[1];
      # first, catalog the scalar
      if ($name ne '') {
        $id = format_refaddr($ref);
        if (exists $s->{seen}{$id}) {
          if ($s->{seen}{$id}[2]) {
  	  $out = $s->{seen}{$id}[0];
  	  #warn "[<$out]\n";
  	  return "\${$out}";
  	}
        }
        else {
  	#warn "[>\\$name]\n";
  	$s->{seen}{$id} = ["\\$name", $ref];
        }
      }
      if (ref($ref) eq 'GLOB' or "$ref" =~ /=GLOB\([^()]+\)$/) {  # glob
        my $name = substr($val, 1);
        if ($name =~ /^[A-Za-z_][\w:]*$/) {
  	$name =~ s/^main::/::/;
  	$sname = $name;
        }
        else {
  	$sname = $s->_dump($name, "");
  	$sname = '{' . $sname . '}';
        }
        if ($s->{purity}) {
  	my $k;
  	local ($s->{level}) = 0;
  	for $k (qw(SCALAR ARRAY HASH)) {
  	  my $gval = *$val{$k};
  	  next unless defined $gval;
  	  next if $k eq "SCALAR" && ! defined $$gval;  # always there
  
  	  # _dump can push into @post, so we hold our place using $postlen
  	  my $postlen = scalar @post;
  	  $post[$postlen] = "\*$sname = ";
  	  local ($s->{apad}) = " " x length($post[$postlen]) if $s->{indent} >= 2;
  	  $post[$postlen] .= $s->_dump($gval, "\*$sname\{$k\}");
  	}
        }
        $out .= '*' . $sname;
      }
      elsif (!defined($val)) {
        $out .= "undef";
      }
      elsif ($val =~ /^(?:0|-?[1-9]\d{0,8})\z/) { # safe decimal number
        $out .= $val;
      }
      else {				 # string
        if ($s->{useqq} or $val =~ tr/\0-\377//c) {
          # Fall back to qq if there's Unicode
  	$out .= qquote($val, $s->{useqq});
        }
        else {
          $out .= _quote($val);
        }
      }
    }
    if ($id) {
      # if we made it this far, $id was added to seen list at current
      # level, so remove it to get deep copies
      if ($s->{deepcopy}) {
        delete($s->{seen}{$id});
      }
      elsif ($name) {
        $s->{seen}{$id}[2] = 1;
      }
    }
    return $out;
  }
    
  #
  # non-OO style of earlier version
  #
  sub Dumper {
    return Data::Dumper->Dump([@_]);
  }
  
  # compat stub
  sub DumperX {
    return Data::Dumper->Dumpxs([@_], []);
  }
  
  sub Dumpf { return Data::Dumper->Dump(@_) }
  
  sub Dumpp { print Data::Dumper->Dump(@_) }
  
  #
  # reset the "seen" cache 
  #
  sub Reset {
    my($s) = shift;
    $s->{seen} = {};
    return $s;
  }
  
  sub Indent {
    my($s, $v) = @_;
    if (defined($v)) {
      if ($v == 0) {
        $s->{xpad} = "";
        $s->{sep} = "";
      }
      else {
        $s->{xpad} = "  ";
        $s->{sep} = "\n";
      }
      $s->{indent} = $v;
      return $s;
    }
    else {
      return $s->{indent};
    }
  }
  
  sub Pair {
      my($s, $v) = @_;
      defined($v) ? (($s->{pair} = $v), return $s) : $s->{pair};
  }
  
  sub Pad {
    my($s, $v) = @_;
    defined($v) ? (($s->{pad} = $v), return $s) : $s->{pad};
  }
  
  sub Varname {
    my($s, $v) = @_;
    defined($v) ? (($s->{varname} = $v), return $s) : $s->{varname};
  }
  
  sub Purity {
    my($s, $v) = @_;
    defined($v) ? (($s->{purity} = $v), return $s) : $s->{purity};
  }
  
  sub Useqq {
    my($s, $v) = @_;
    defined($v) ? (($s->{useqq} = $v), return $s) : $s->{useqq};
  }
  
  sub Terse {
    my($s, $v) = @_;
    defined($v) ? (($s->{terse} = $v), return $s) : $s->{terse};
  }
  
  sub Freezer {
    my($s, $v) = @_;
    defined($v) ? (($s->{freezer} = $v), return $s) : $s->{freezer};
  }
  
  sub Toaster {
    my($s, $v) = @_;
    defined($v) ? (($s->{toaster} = $v), return $s) : $s->{toaster};
  }
  
  sub Deepcopy {
    my($s, $v) = @_;
    defined($v) ? (($s->{deepcopy} = $v), return $s) : $s->{deepcopy};
  }
  
  sub Quotekeys {
    my($s, $v) = @_;
    defined($v) ? (($s->{quotekeys} = $v), return $s) : $s->{quotekeys};
  }
  
  sub Bless {
    my($s, $v) = @_;
    defined($v) ? (($s->{'bless'} = $v), return $s) : $s->{'bless'};
  }
  
  sub Maxdepth {
    my($s, $v) = @_;
    defined($v) ? (($s->{'maxdepth'} = $v), return $s) : $s->{'maxdepth'};
  }
  
  sub Useperl {
    my($s, $v) = @_;
    defined($v) ? (($s->{'useperl'} = $v), return $s) : $s->{'useperl'};
  }
  
  sub Sortkeys {
    my($s, $v) = @_;
    defined($v) ? (($s->{'sortkeys'} = $v), return $s) : $s->{'sortkeys'};
  }
  
  sub Deparse {
    my($s, $v) = @_;
    defined($v) ? (($s->{'deparse'} = $v), return $s) : $s->{'deparse'};
  }
  
  # used by qquote below
  my %esc = (  
      "\a" => "\\a",
      "\b" => "\\b",
      "\t" => "\\t",
      "\n" => "\\n",
      "\f" => "\\f",
      "\r" => "\\r",
      "\e" => "\\e",
  );
  
  # put a string value in double quotes
  sub qquote {
    local($_) = shift;
    s/([\\\"\@\$])/\\$1/g;
    my $bytes; { use bytes; $bytes = length }
    s/([^\x00-\x7f])/'\x{'.sprintf("%x",ord($1)).'}'/ge if $bytes > length;
    return qq("$_") unless 
      /[^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~]/;  # fast exit
  
    my $high = shift || "";
    s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
  
    if (ord('^')==94)  { # ascii
      # no need for 3 digits in escape for these
      s/([\0-\037])(?!\d)/'\\'.sprintf('%o',ord($1))/eg;
      s/([\0-\037\177])/'\\'.sprintf('%03o',ord($1))/eg;
      # all but last branch below not supported --BEHAVIOR SUBJECT TO CHANGE--
      if ($high eq "iso8859") {
        s/([\200-\240])/'\\'.sprintf('%o',ord($1))/eg;
      } elsif ($high eq "utf8") {
  #     use utf8;
  #     $str =~ s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      } elsif ($high eq "8bit") {
          # leave it as it is
      } else {
        s/([\200-\377])/'\\'.sprintf('%03o',ord($1))/eg;
        s/([^\040-\176])/sprintf "\\x{%04x}", ord($1)/ge;
      }
    }
    else { # ebcdic
        s{([^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~])(?!\d)}
         {my $v = ord($1); '\\'.sprintf(($v <= 037 ? '%o' : '%03o'), $v)}eg;
        s{([^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@A-Z[\\\]^_`a-z{|}~])}
         {'\\'.sprintf('%03o',ord($1))}eg;
    }
  
    return qq("$_");
  }
  
  # helper sub to sort hash keys in Perl < 5.8.0 where we don't have
  # access to sortsv() from XS
  sub _sortkeys { [ sort keys %{$_[0]} ] }
  
  1;
  __END__
  
  =head1 NAME
  
  Data::Dumper - stringified perl data structures, suitable for both printing and C<eval>
  
  =head1 SYNOPSIS
  
      use Data::Dumper;
  
      # simple procedural interface
      print Dumper($foo, $bar);
  
      # extended usage with names
      print Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
  
      # configuration variables
      {
        local $Data::Dumper::Purity = 1;
        eval Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
      }
  
      # OO usage
      $d = Data::Dumper->new([$foo, $bar], [qw(foo *ary)]);
         ...
      print $d->Dump;
         ...
      $d->Purity(1)->Terse(1)->Deepcopy(1);
      eval $d->Dump;
  
  
  =head1 DESCRIPTION
  
  Given a list of scalars or reference variables, writes out their contents in
  perl syntax. The references can also be objects.  The content of each
  variable is output in a single Perl statement.  Handles self-referential
  structures correctly.
  
  The return value can be C<eval>ed to get back an identical copy of the
  original reference structure.
  
  Any references that are the same as one of those passed in will be named
  C<$VAR>I<n> (where I<n> is a numeric suffix), and other duplicate references
  to substructures within C<$VAR>I<n> will be appropriately labeled using arrow
  notation.  You can specify names for individual values to be dumped if you
  use the C<Dump()> method, or you can change the default C<$VAR> prefix to
  something else.  See C<$Data::Dumper::Varname> and C<$Data::Dumper::Terse>
  below.
  
  The default output of self-referential structures can be C<eval>ed, but the
  nested references to C<$VAR>I<n> will be undefined, since a recursive
  structure cannot be constructed using one Perl statement.  You should set the
  C<Purity> flag to 1 to get additional statements that will correctly fill in
  these references.  Moreover, if C<eval>ed when strictures are in effect,
  you need to ensure that any variables it accesses are previously declared.
  
  In the extended usage form, the references to be dumped can be given
  user-specified names.  If a name begins with a C<*>, the output will 
  describe the dereferenced type of the supplied reference for hashes and
  arrays, and coderefs.  Output of names will be avoided where possible if
  the C<Terse> flag is set.
  
  In many cases, methods that are used to set the internal state of the
  object will return the object itself, so method calls can be conveniently
  chained together.
  
  Several styles of output are possible, all controlled by setting
  the C<Indent> flag.  See L<Configuration Variables or Methods> below 
  for details.
  
  
  =head2 Methods
  
  =over 4
  
  =item I<PACKAGE>->new(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns a newly created C<Data::Dumper> object.  The first argument is an
  anonymous array of values to be dumped.  The optional second argument is an
  anonymous array of names for the values.  The names need not have a leading
  C<$> sign, and must be comprised of alphanumeric characters.  You can begin
  a name with a C<*> to specify that the dereferenced type must be dumped
  instead of the reference itself, for ARRAY and HASH references.
  
  The prefix specified by C<$Data::Dumper::Varname> will be used with a
  numeric suffix if the name for a value is undefined.
  
  Data::Dumper will catalog all references encountered while dumping the
  values. Cross-references (in the form of names of substructures in perl
  syntax) will be inserted at all possible points, preserving any structural
  interdependencies in the original set of values.  Structure traversal is
  depth-first,  and proceeds in order from the first supplied value to
  the last.
  
  =item I<$OBJ>->Dump  I<or>  I<PACKAGE>->Dump(I<ARRAYREF [>, I<ARRAYREF]>)
  
  Returns the stringified form of the values stored in the object (preserving
  the order in which they were supplied to C<new>), subject to the
  configuration options below.  In a list context, it returns a list
  of strings corresponding to the supplied values.
  
  The second form, for convenience, simply calls the C<new> method on its
  arguments before dumping the object immediately.
  
  =item I<$OBJ>->Seen(I<[HASHREF]>)
  
  Queries or adds to the internal table of already encountered references.
  You must use C<Reset> to explicitly clear the table if needed.  Such
  references are not dumped; instead, their names are inserted wherever they
  are encountered subsequently.  This is useful especially for properly
  dumping subroutine references.
  
  Expects an anonymous hash of name => value pairs.  Same rules apply for names
  as in C<new>.  If no argument is supplied, will return the "seen" list of
  name => value pairs, in a list context.  Otherwise, returns the object
  itself.
  
  =item I<$OBJ>->Values(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of values that will be dumped.
  When called without arguments, returns the values.  Otherwise, returns the
  object itself.
  
  =item I<$OBJ>->Names(I<[ARRAYREF]>)
  
  Queries or replaces the internal array of user supplied names for the values
  that will be dumped.  When called without arguments, returns the names.
  Otherwise, returns the object itself.
  
  =item I<$OBJ>->Reset
  
  Clears the internal table of "seen" references and returns the object
  itself.
  
  =back
  
  =head2 Functions
  
  =over 4
  
  =item Dumper(I<LIST>)
  
  Returns the stringified form of the values in the list, subject to the
  configuration options below.  The values will be named C<$VAR>I<n> in the
  output, where I<n> is a numeric suffix.  Will return a list of strings
  in a list context.
  
  =back
  
  =head2 Configuration Variables or Methods
  
  Several configuration variables can be used to control the kind of output
  generated when using the procedural interface.  These variables are usually
  C<local>ized in a block so that other parts of the code are not affected by
  the change.  
  
  These variables determine the default state of the object created by calling
  the C<new> method, but cannot be used to alter the state of the object
  thereafter.  The equivalent method names should be used instead to query
  or set the internal state of the object.
  
  The method forms return the object itself when called with arguments,
  so that they can be chained together nicely.
  
  =over 4
  
  =item *
  
  $Data::Dumper::Indent  I<or>  I<$OBJ>->Indent(I<[NEWVAL]>)
  
  Controls the style of indentation.  It can be set to 0, 1, 2 or 3.  Style 0
  spews output without any newlines, indentation, or spaces between list
  items.  It is the most compact format possible that can still be called
  valid perl.  Style 1 outputs a readable form with newlines but no fancy
  indentation (each level in the structure is simply indented by a fixed
  amount of whitespace).  Style 2 (the default) outputs a very readable form
  which takes into account the length of hash keys (so the hash value lines
  up).  Style 3 is like style 2, but also annotates the elements of arrays
  with their index (but the comment is on its own line, so array output
  consumes twice the number of lines).  Style 2 is the default.
  
  =item *
  
  $Data::Dumper::Purity  I<or>  I<$OBJ>->Purity(I<[NEWVAL]>)
  
  Controls the degree to which the output can be C<eval>ed to recreate the
  supplied reference structures.  Setting it to 1 will output additional perl
  statements that will correctly recreate nested references.  The default is
  0.
  
  =item *
  
  $Data::Dumper::Pad  I<or>  I<$OBJ>->Pad(I<[NEWVAL]>)
  
  Specifies the string that will be prefixed to every line of the output.
  Empty string by default.
  
  =item *
  
  $Data::Dumper::Varname  I<or>  I<$OBJ>->Varname(I<[NEWVAL]>)
  
  Contains the prefix to use for tagging variable names in the output. The
  default is "VAR".
  
  =item *
  
  $Data::Dumper::Useqq  I<or>  I<$OBJ>->Useqq(I<[NEWVAL]>)
  
  When set, enables the use of double quotes for representing string values.
  Whitespace other than space will be represented as C<[\n\t\r]>, "unsafe"
  characters will be backslashed, and unprintable characters will be output as
  quoted octal integers.  Since setting this variable imposes a performance
  penalty, the default is 0.  C<Dump()> will run slower if this flag is set,
  since the fast XSUB implementation doesn't support it yet.
  
  =item *
  
  $Data::Dumper::Terse  I<or>  I<$OBJ>->Terse(I<[NEWVAL]>)
  
  When set, Data::Dumper will emit single, non-self-referential values as
  atoms/terms rather than statements.  This means that the C<$VAR>I<n> names
  will be avoided where possible, but be advised that such output may not
  always be parseable by C<eval>.
  
  =item *
  
  $Data::Dumper::Freezer  I<or>  $I<OBJ>->Freezer(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will invoke that method via the object before attempting to
  stringify it.  This method can alter the contents of the object (if, for
  instance, it contains data allocated from C), and even rebless it in a
  different package.  The client is responsible for making sure the specified
  method can be called via the object, and that the object ends up containing
  only perl data types after the method has been called.  Defaults to an empty
  string.
  
  If an object does not support the method specified (determined using
  UNIVERSAL::can()) then the call will be skipped.  If the method dies a
  warning will be generated.
  
  =item *
  
  $Data::Dumper::Toaster  I<or>  $I<OBJ>->Toaster(I<[NEWVAL]>)
  
  Can be set to a method name, or to an empty string to disable the feature.
  Data::Dumper will emit a method call for any objects that are to be dumped
  using the syntax C<bless(DATA, CLASS)-E<gt>METHOD()>.  Note that this means that
  the method specified will have to perform any modifications required on the
  object (like creating new state within it, and/or reblessing it in a
  different package) and then return it.  The client is responsible for making
  sure the method can be called via the object, and that it returns a valid
  object.  Defaults to an empty string.
  
  =item *
  
  $Data::Dumper::Deepcopy  I<or>  $I<OBJ>->Deepcopy(I<[NEWVAL]>)
  
  Can be set to a boolean value to enable deep copies of structures.
  Cross-referencing will then only be done when absolutely essential
  (i.e., to break reference cycles).  Default is 0.
  
  =item *
  
  $Data::Dumper::Quotekeys  I<or>  $I<OBJ>->Quotekeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are quoted.
  A false value will avoid quoting hash keys when it looks like a simple
  string.  Default is 1, which will always enclose hash keys in quotes.
  
  =item *
  
  $Data::Dumper::Bless  I<or>  $I<OBJ>->Bless(I<[NEWVAL]>)
  
  Can be set to a string that specifies an alternative to the C<bless>
  builtin operator used to create objects.  A function with the specified
  name should exist, and should accept the same arguments as the builtin.
  Default is C<bless>.
  
  =item *
  
  $Data::Dumper::Pair  I<or>  $I<OBJ>->Pair(I<[NEWVAL]>)
  
  Can be set to a string that specifies the separator between hash keys
  and values. To dump nested hash, array and scalar values to JavaScript,
  use: C<$Data::Dumper::Pair = ' : ';>. Implementing C<bless> in JavaScript
  is left as an exercise for the reader.
  A function with the specified name exists, and accepts the same arguments
  as the builtin.
  
  Default is: C< =E<gt> >.
  
  =item *
  
  $Data::Dumper::Maxdepth  I<or>  $I<OBJ>->Maxdepth(I<[NEWVAL]>)
  
  Can be set to a positive integer that specifies the depth beyond which
  we don't venture into a structure.  Has no effect when
  C<Data::Dumper::Purity> is set.  (Useful in debugger when we often don't
  want to see more than enough).  Default is 0, which means there is 
  no maximum depth. 
  
  =item *
  
  $Data::Dumper::Useperl  I<or>  $I<OBJ>->Useperl(I<[NEWVAL]>)
  
  Can be set to a boolean value which controls whether the pure Perl
  implementation of C<Data::Dumper> is used. The C<Data::Dumper> module is
  a dual implementation, with almost all functionality written in both
  pure Perl and also in XS ('C'). Since the XS version is much faster, it
  will always be used if possible. This option lets you override the
  default behavior, usually for testing purposes only. Default is 0, which
  means the XS implementation will be used if possible.
  
  =item *
  
  $Data::Dumper::Sortkeys  I<or>  $I<OBJ>->Sortkeys(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether hash keys are dumped in
  sorted order. A true value will cause the keys of all hashes to be
  dumped in Perl's default sort order. Can also be set to a subroutine
  reference which will be called for each hash that is dumped. In this
  case C<Data::Dumper> will call the subroutine once for each hash,
  passing it the reference of the hash. The purpose of the subroutine is
  to return a reference to an array of the keys that will be dumped, in
  the order that they should be dumped. Using this feature, you can
  control both the order of the keys, and which keys are actually used. In
  other words, this subroutine acts as a filter by which you can exclude
  certain keys from being dumped. Default is 0, which means that hash keys
  are not sorted.
  
  =item *
  
  $Data::Dumper::Deparse  I<or>  $I<OBJ>->Deparse(I<[NEWVAL]>)
  
  Can be set to a boolean value to control whether code references are
  turned into perl source code. If set to a true value, C<B::Deparse>
  will be used to get the source of the code reference. Using this option
  will force using the Perl implementation of the dumper, since the fast
  XSUB implementation doesn't support it.
  
  Caution : use this option only if you know that your coderefs will be
  properly reconstructed by C<B::Deparse>.
  
  =back
  
  =head2 Exports
  
  =over 4
  
  =item Dumper
  
  =back
  
  =head1 EXAMPLES
  
  Run these code snippets to get a quick feel for the behavior of this
  module.  When you are through with these examples, you may want to
  add or change the various configuration variables described above,
  to see their behavior.  (See the testsuite in the Data::Dumper
  distribution for more examples.)
  
  
      use Data::Dumper;
  
      package Foo;
      sub new {bless {'a' => 1, 'b' => sub { return "foo" }}, $_[0]};
  
      package Fuz;                       # a weird REF-REF-SCALAR object
      sub new {bless \($_ = \ 'fu\'z'), $_[0]};
  
      package main;
      $foo = Foo->new;
      $fuz = Fuz->new;
      $boo = [ 1, [], "abcd", \*foo,
               {1 => 'a', 023 => 'b', 0x45 => 'c'}, 
               \\"p\q\'r", $foo, $fuz];
  
      ########
      # simple usage
      ########
  
      $bar = eval(Dumper($boo));
      print($@) if $@;
      print Dumper($boo), Dumper($bar);  # pretty print (no array indices)
  
      $Data::Dumper::Terse = 1;          # don't output names where feasible
      $Data::Dumper::Indent = 0;         # turn off all pretty print
      print Dumper($boo), "\n";
  
      $Data::Dumper::Indent = 1;         # mild pretty print
      print Dumper($boo);
  
      $Data::Dumper::Indent = 3;         # pretty print with array indices
      print Dumper($boo);
  
      $Data::Dumper::Useqq = 1;          # print strings in double quotes
      print Dumper($boo);
  
      $Data::Dumper::Pair = " : ";       # specify hash key/value separator
      print Dumper($boo);
  
  
      ########
      # recursive structures
      ########
  
      @c = ('c');
      $c = \@c;
      $b = {};
      $a = [1, $b, $c];
      $b->{a} = $a;
      $b->{b} = $a->[1];
      $b->{c} = $a->[2];
      print Data::Dumper->Dump([$a,$b,$c], [qw(a b c)]);
  
  
      $Data::Dumper::Purity = 1;         # fill in the holes for eval
      print Data::Dumper->Dump([$a, $b], [qw(*a b)]); # print as @a
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]); # print as %b
  
  
      $Data::Dumper::Deepcopy = 1;       # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
  
      $Data::Dumper::Purity = 0;         # avoid cross-refs
      print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
  
      ########
      # deep structures
      ########
  
      $a = "pearl";
      $b = [ $a ];
      $c = { 'b' => $b };
      $d = [ $c ];
      $e = { 'd' => $d };
      $f = { 'e' => $e };
      print Data::Dumper->Dump([$f], [qw(f)]);
  
      $Data::Dumper::Maxdepth = 3;       # no deeper than 3 refs down
      print Data::Dumper->Dump([$f], [qw(f)]);
  
  
      ########
      # object-oriented usage
      ########
  
      $d = Data::Dumper->new([$a,$b], [qw(a b)]);
      $d->Seen({'*c' => $c});            # stash a ref without printing it
      $d->Indent(3);
      print $d->Dump;
      $d->Reset->Purity(0);              # empty the seen cache
      print join "----\n", $d->Dump;
  
  
      ########
      # persistence
      ########
  
      package Foo;
      sub new { bless { state => 'awake' }, shift }
      sub Freeze {
          my $s = shift;
  	print STDERR "preparing to sleep\n";
  	$s->{state} = 'asleep';
  	return bless $s, 'Foo::ZZZ';
      }
  
      package Foo::ZZZ;
      sub Thaw {
          my $s = shift;
  	print STDERR "waking up\n";
  	$s->{state} = 'awake';
  	return bless $s, 'Foo';
      }
  
      package Foo;
      use Data::Dumper;
      $a = Foo->new;
      $b = Data::Dumper->new([$a], ['c']);
      $b->Freezer('Freeze');
      $b->Toaster('Thaw');
      $c = $b->Dump;
      print $c;
      $d = eval $c;
      print Data::Dumper->Dump([$d], ['d']);
  
  
      ########
      # symbol substitution (useful for recreating CODE refs)
      ########
  
      sub foo { print "foo speaking\n" }
      *other = \&foo;
      $bar = [ \&other ];
      $d = Data::Dumper->new([\&other,$bar],['*other','bar']);
      $d->Seen({ '*foo' => \&foo });
      print $d->Dump;
  
  
      ########
      # sorting and filtering hash keys
      ########
  
      $Data::Dumper::Sortkeys = \&my_filter;
      my $foo = { map { (ord, "$_$_$_") } 'I'..'Q' };
      my $bar = { %$foo };
      my $baz = { reverse %$foo };
      print Dumper [ $foo, $bar, $baz ];
  
      sub my_filter {
          my ($hash) = @_;
          # return an array ref containing the hash keys to dump
          # in the order that you want them to be dumped
          return [
            # Sort the keys of %$foo in reverse numeric order
              $hash eq $foo ? (sort {$b <=> $a} keys %$hash) :
            # Only dump the odd number keys of %$bar
              $hash eq $bar ? (grep {$_ % 2} keys %$hash) :
            # Sort keys in default order for all other hashes
              (sort keys %$hash)
          ];
      }
  
  =head1 BUGS
  
  Due to limitations of Perl subroutine call semantics, you cannot pass an
  array or hash.  Prepend it with a C<\> to pass its reference instead.  This
  will be remedied in time, now that Perl has subroutine prototypes.
  For now, you need to use the extended usage form, and prepend the
  name with a C<*> to output it as a hash or array.
  
  C<Data::Dumper> cheats with CODE references.  If a code reference is
  encountered in the structure being processed (and if you haven't set
  the C<Deparse> flag), an anonymous subroutine that
  contains the string '"DUMMY"' will be inserted in its place, and a warning
  will be printed if C<Purity> is set.  You can C<eval> the result, but bear
  in mind that the anonymous sub that gets created is just a placeholder.
  Someday, perl will have a switch to cache-on-demand the string
  representation of a compiled piece of code, I hope.  If you have prior
  knowledge of all the code refs that your data structures are likely
  to have, you can use the C<Seen> method to pre-seed the internal reference
  table and make the dumped output point to them, instead.  See L</EXAMPLES>
  above.
  
  The C<Useqq> and C<Deparse> flags makes Dump() run slower, since the
  XSUB implementation does not support them.
  
  SCALAR objects have the weirdest looking C<bless> workaround.
  
  Pure Perl version of C<Data::Dumper> escapes UTF-8 strings correctly
  only in Perl 5.8.0 and later.
  
  =head2 NOTE
  
  Starting from Perl 5.8.1 different runs of Perl will have different
  ordering of hash keys.  The change was done for greater security,
  see L<perlsec/"Algorithmic Complexity Attacks">.  This means that
  different runs of Perl will have different Data::Dumper outputs if
  the data contains hashes.  If you need to have identical Data::Dumper
  outputs from different runs of Perl, use the environment variable
  PERL_HASH_SEED, see L<perlrun/PERL_HASH_SEED>.  Using this restores
  the old (platform-specific) ordering: an even prettier solution might
  be to use the C<Sortkeys> filter of Data::Dumper.
  
  =head1 AUTHOR
  
  Gurusamy Sarathy        gsar@activestate.com
  
  Copyright (c) 1996-98 Gurusamy Sarathy. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 VERSION
  
  Version 2.125  (Aug  8 2009)
  
  =head1 SEE ALSO
  
  perl(1)
  
  =cut
I386-LINUX-THREAD-MULTI_DATA_DUMPER

$fatpacked{"i386-linux-thread-multi/List/Util.pm"} = <<'I386-LINUX-THREAD-MULTI_LIST_UTIL';
  # List::Util.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # This module is normally only loaded if the XS module is not available
  
  package List::Util;
  
  use strict;
  use vars qw(@ISA @EXPORT_OK $VERSION $XS_VERSION $TESTING_PERL_ONLY);
  require Exporter;
  
  @ISA        = qw(Exporter);
  @EXPORT_OK  = qw(first min max minstr maxstr reduce sum shuffle);
  $VERSION    = "1.22";
  $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  eval {
    # PERL_DL_NONLAZY must be false, or any errors in loading will just
    # cause the perl code to be tested
    local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
    eval {
      require XSLoader;
      XSLoader::load('List::Util', $XS_VERSION);
      1;
    } or do {
      require DynaLoader;
      local @ISA = qw(DynaLoader);
      bootstrap List::Util $XS_VERSION;
    };
  } unless $TESTING_PERL_ONLY;
  
  
  if (!defined &sum) {
    require List::Util::PP;
    List::Util::PP->import;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines. The
  subroutines defined are
  
  =over 4
  
  =item first BLOCK LIST
  
  Similar to C<grep> in that it evaluates BLOCK setting C<$_> to each element
  of LIST in turn. C<first> returns the first element where the result from
  BLOCK is a true value. If BLOCK never returns true or LIST was empty then
  C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { defined($a) ? $a : wanted($b) ? $b : undef } undef, @list
  
  for example wanted() could be defined() which would return the first
  defined value in @list
  
  =item max LIST
  
  Returns the entry in the list with the highest numerical value. If the
  list is empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a > $b ? $a : $b } 1..10
  
  =item maxstr LIST
  
  Similar to C<max>, but treats all the entries in the list as strings
  and returns the highest string as defined by the C<gt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'
  
  =item min LIST
  
  Similar to C<max> but returns the entry in the list with the lowest
  numerical value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a < $b ? $a : $b } 1..10
  
  =item minstr LIST
  
  Similar to C<min>, but treats all the entries in the list as strings
  and returns the lowest string as defined by the C<lt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a lt $b ? $a : $b } 'A'..'Z'
  
  =item reduce BLOCK LIST
  
  Reduces LIST by calling BLOCK, in a scalar context, multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a>
  and C<$b> set to the first two elements of the list, subsequent
  calls will be done by setting C<$a> to the result of the previous
  call and C<$b> to the next element in the list.
  
  Returns the result of the last call to BLOCK. If LIST is empty then
  C<undef> is returned. If LIST only contains one element then that
  element is returned and BLOCK is not executed.
  
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
  If your algorithm requires that C<reduce> produce an identity value, then
  make sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  =item shuffle LIST
  
  Returns the elements of LIST in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =item sum LIST
  
  Returns the sum of all the elements in LIST. If LIST is empty then
  C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a + $b } 1..10
  
  If your algorithm requires that C<sum> produce an identity of 0, then
  make sure that you always pass C<0> as the first argument to prevent
  C<undef> being returned
  
    $foo = sum 0, @values;
  
  =back
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce
  will return an incorrect result. This will show up as test 7 of
  reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # One argument is true
  
    sub any { $_ && return 1 for @_; 0 }
  
    # All arguments are true
  
    sub all { $_ || return 0 for @_; 1 }
  
    # All arguments are false
  
    sub none { $_ && return 0 for @_; 1 }
  
    # One argument is false
  
    sub notall { $_ || return 1 for @_; 0 }
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
I386-LINUX-THREAD-MULTI_LIST_UTIL

$fatpacked{"i386-linux-thread-multi/List/Util/PP.pm"} = <<'I386-LINUX-THREAD-MULTI_LIST_UTIL_PP';
  # List::Util::PP.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package List::Util::PP;
  
  use strict;
  use warnings;
  use vars qw(@ISA @EXPORT $VERSION $a $b);
  require Exporter;
  
  @ISA     = qw(Exporter);
  @EXPORT  = qw(first min max minstr maxstr reduce sum shuffle);
  $VERSION = "1.22";
  $VERSION = eval $VERSION;
  
  sub reduce (&@) {
    my $code = shift;
    require Scalar::Util;
    my $type = Scalar::Util::reftype($code);
    unless($type and $type eq 'CODE') {
      require Carp;
      Carp::croak("Not a subroutine reference");
    }
    no strict 'refs';
  
    return shift unless @_ > 1;
  
    use vars qw($a $b);
  
    my $caller = caller;
    local(*{$caller."::a"}) = \my $a;
    local(*{$caller."::b"}) = \my $b;
  
    $a = shift;
    foreach (@_) {
      $b = $_;
      $a = &{$code}();
    }
  
    $a;
  }
  
  sub first (&@) {
    my $code = shift;
    require Scalar::Util;
    my $type = Scalar::Util::reftype($code);
    unless($type and $type eq 'CODE') {
      require Carp;
      Carp::croak("Not a subroutine reference");
    }
  
    foreach (@_) {
      return $_ if &{$code}();
    }
  
    undef;
  }
  
  
  sub sum (@) { reduce { $a + $b } @_ }
  
  sub min (@) { reduce { $a < $b ? $a : $b } @_ }
  
  sub max (@) { reduce { $a > $b ? $a : $b } @_ }
  
  sub minstr (@) { reduce { $a lt $b ? $a : $b } @_ }
  
  sub maxstr (@) { reduce { $a gt $b ? $a : $b } @_ }
  
  sub shuffle (@) {
    my @a=\(@_);
    my $n;
    my $i=@_;
    map {
      $n = rand($i--);
      (${$a[$n]}, $a[$n] = $a[$i])[0];
    } @_;
  }
  
  1;
I386-LINUX-THREAD-MULTI_LIST_UTIL_PP

$fatpacked{"i386-linux-thread-multi/List/Util/XS.pm"} = <<'I386-LINUX-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use vars qw($VERSION);
  use List::Util;
  
  $VERSION = "1.22";           # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  sub _VERSION { # FIXUP
    require Carp;
    Carp::croak("You need to install Scalar-List-Utils with a C compiler to ensure the XS is compiled")
      if defined $_[1];
    $VERSION;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
I386-LINUX-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"i386-linux-thread-multi/Scalar/Util.pm"} = <<'I386-LINUX-THREAD-MULTI_SCALAR_UTIL';
  # Scalar::Util.pm
  #
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Scalar::Util;
  
  use strict;
  use vars qw(@ISA @EXPORT_OK $VERSION @EXPORT_FAIL);
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  @ISA       = qw(Exporter);
  @EXPORT_OK = qw(blessed dualvar reftype weaken isweak tainted readonly openhandle refaddr isvstring looks_like_number set_prototype);
  $VERSION    = "1.22";
  $VERSION   = eval $VERSION;
  
  unless (defined &dualvar) {
    # Load Pure Perl version if XS not loaded
    require Scalar::Util::PP;
    Scalar::Util::PP->import;
    push @EXPORT_FAIL, qw(weaken isweak dualvar isvstring set_prototype);
  }
  
  sub export_fail {
    if (grep { /dualvar/ } @EXPORT_FAIL) { # no XS loaded
      my $pat = join("|", @EXPORT_FAIL);
      if (my ($err) = grep { /^($pat)$/ } @_ ) {
        require Carp;
        Carp::croak("$err is only available with the XS version of Scalar::Util");
      }
    }
  
    if (grep { /^(weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^(isvstring)$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  sub openhandle ($) {
    my $fh = shift;
    my $rt = reftype($fh) || '';
  
    return defined(fileno($fh)) ? $fh : undef
      if $rt eq 'IO';
  
    if (reftype(\$fh) eq 'GLOB') { # handle  openhandle(*DATA)
      $fh = \(my $tmp=$fh);
    }
    elsif ($rt ne 'GLOB') {
      return undef;
    }
  
    (tied(*$fh) or defined(fileno($fh)))
      ? $fh : undef;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isweak readonly refaddr reftype tainted
                          weaken isvstring looks_like_number set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines. The
  subroutines defined are
  
  =over 4
  
  =item blessed EXPR
  
  If EXPR evaluates to a blessed reference the name of the package
  that it is blessed into is returned. Otherwise C<undef> is returned.
  
     $scalar = "foo";
     $class  = blessed $scalar;           # undef
  
     $ref    = [];
     $class  = blessed $ref;              # undef
  
     $obj    = bless [], "Foo";
     $class  = blessed $obj;              # "Foo"
  
  =item dualvar NUM, STRING
  
  Returns a scalar that has the value NUM in a numeric context and the
  value STRING in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =item isvstring EXPR
  
  If EXPR is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =item isweak EXPR
  
  If EXPR is a scalar which is a weak reference the result is true.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =item looks_like_number EXPR
  
  Returns true if perl thinks EXPR is a number. See
  L<perlapi/looks_like_number>.
  
  =item openhandle FH
  
  Returns FH if FH may be used as a filehandle and is open, or FH is a tied
  handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);		# \*STDIN
      $fh = openhandle(\*STDIN);		# \*STDIN
      $fh = openhandle(*NOTOPEN);		# undef
      $fh = openhandle("scalar");		# undef
      
  =item readonly SCALAR
  
  Returns true if SCALAR is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =item refaddr EXPR
  
  If EXPR evaluates to a reference the internal memory address of
  the referenced value is returned. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =item reftype EXPR
  
  If EXPR evaluates to a reference the type of the variable referenced
  is returned. Otherwise C<undef> is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =item set_prototype CODEREF, PROTOTYPE
  
  Sets the prototype of the given function, or deletes it if PROTOTYPE is
  undef. Returns the CODEREF.
  
      set_prototype \&foo, '$$';
  
  =item tainted EXPR
  
  Return true if the result of EXPR is tainted
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =item weaken REF
  
  REF will be turned into a weak reference. This means that it will not
  hold a reference count on the object it references. Also when the reference
  count on that object reaches zero, REF will be set to undef.
  
  This is useful for keeping copies of references , but you don't want to
  prevent the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference,
  the copy will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never
  be destroyed because there is now always a strong reference to them in the
  @object array.
  
  =back
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to use
  C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its functions
  so that those without access to a C compiler may still use it. However some of the functions
  are only available when a C compiler was available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
I386-LINUX-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"i386-linux-thread-multi/Scalar/Util/PP.pm"} = <<'I386-LINUX-THREAD-MULTI_SCALAR_UTIL_PP';
  # Scalar::Util::PP.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # This module is normally only loaded if the XS module is not available
  
  package Scalar::Util::PP;
  
  use strict;
  use warnings;
  use vars qw(@ISA @EXPORT $VERSION $recurse);
  require Exporter;
  use B qw(svref_2object);
  
  @ISA     = qw(Exporter);
  @EXPORT  = qw(blessed reftype tainted readonly refaddr looks_like_number);
  $VERSION = "1.22";
  $VERSION = eval $VERSION;
  
  sub blessed ($) {
    return undef unless length(ref($_[0]));
    my $b = svref_2object($_[0]);
    return undef unless $b->isa('B::PVMG');
    my $s = $b->SvSTASH;
    return $s->isa('B::HV') ? $s->NAME : undef;
  }
  
  sub refaddr($) {
    return undef unless length(ref($_[0]));
  
    my $addr;
    if(defined(my $pkg = blessed($_[0]))) {
      $addr .= bless $_[0], 'Scalar::Util::Fake';
      bless $_[0], $pkg;
    }
    else {
      $addr .= $_[0]
    }
  
    $addr =~ /0x(\w+)/;
    local $^W;
    hex($1);
  }
  
  {
    my %tmap = qw(
      B::HV HASH
      B::AV ARRAY
      B::CV CODE
      B::IO IO
      B::NULL SCALAR
      B::NV SCALAR
      B::PV SCALAR
      B::GV GLOB
      B::RV REF
      B::REGEXP REGEXP
    );
  
    sub reftype ($) {
      my $r = shift;
  
      return undef unless length(ref($r));
  
      my $t = ref(svref_2object($r));
  
      return
          exists $tmap{$t} ? $tmap{$t}
        : length(ref($$r)) ? 'REF'
        :                    'SCALAR';
    }
  }
  
  sub tainted {
    local($@, $SIG{__DIE__}, $SIG{__WARN__});
    local $^W = 0;
    no warnings;
    eval { kill 0 * $_[0] };
    $@ =~ /^Insecure/;
  }
  
  sub readonly {
    return 0 if tied($_[0]) || (ref(\($_[0])) ne "SCALAR");
  
    local($@, $SIG{__DIE__}, $SIG{__WARN__});
    my $tmp = $_[0];
  
    !eval { $_[0] = $tmp; 1 };
  }
  
  sub looks_like_number {
    local $_ = shift;
  
    # checks from perlfaq4
    return 0 if !defined($_);
    if (ref($_)) {
      require overload;
      return overload::Overloaded($_) ? defined(0 + $_) : 0;
    }
    return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
    return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
    return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
    0;
  }
  
  
  1;
I386-LINUX-THREAD-MULTI_SCALAR_UTIL_PP

$fatpacked{"i386-linux-thread-multi/version.pm"} = <<'I386-LINUX-THREAD-MULTI_VERSION';
  #!perl -w
  package version;
  
  use 5.005_04;
  use strict;
  
  use vars qw(@ISA $VERSION $CLASS *declare *qv);
  
  $VERSION = 0.78;
  
  $CLASS = 'version';
  
  eval "use version::vxs $VERSION";
  if ( $@ ) { # don't have the XS version installed
      eval "use version::vpp $VERSION"; # don't tempt fate
      die "$@" if ( $@ );
      push @ISA, "version::vpp";
      local $^W;
      *version::qv = \&version::vpp::qv;
      *version::declare = \&version::vpp::declare;
      *version::_VERSION = \&version::vpp::_VERSION;
      if ($] > 5.009001 && $] <= 5.010000) {
  	no strict 'refs';
  	*{'version::stringify'} = \*version::vpp::stringify;
  	*{'version::(""'} = \*version::vpp::stringify;
  	*{'version::new'} = \*version::vpp::new;
      }
  }
  else { # use XS module
      push @ISA, "version::vxs";
      local $^W;
      *version::declare = \&version::vxs::declare;
      *version::qv = \&version::vxs::qv;
      *version::_VERSION = \&version::vxs::_VERSION;
      if ($] > 5.009001 && $] < 5.010000) {
  	no strict 'refs';
  	*{'version::stringify'} = \*version::vxs::stringify;
  	*{'version::(""'} = \*version::vxs::stringify;
      }
      elsif ($] == 5.010000) {
  	no strict 'refs';
  	*{'version::stringify'} = \*version::vxs::stringify;
  	*{'version::(""'} = \*version::vxs::stringify;
  	*version::new = \&version::vxs::new;
  	*version::parse = \&version::vxs::parse;
      }
  
  }
  
  # Preloaded methods go here.
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq 'version') {
  	local $^W;
  	*{$class.'::declare'} =  \&version::declare;
  	*{$class.'::qv'} = \&version::qv;
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
      	%args = 
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
      
      if (exists($args{declare})) {
  	*{$callpkg."::declare"} = 
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg."::qv"} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{"$callpkg\::qv"});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION 
  		= \&version::_VERSION;
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg."::VERSION"} = \&version::_VERSION;
      }
  }
  
  1;
I386-LINUX-THREAD-MULTI_VERSION

$fatpacked{"i386-linux-thread-multi/version/vxs.pm"} = <<'I386-LINUX-THREAD-MULTI_VERSION_VXS';
  #!perl -w
  package version::vxs;
  
  use 5.005_03;
  use strict;
  
  use vars qw(@ISA $VERSION $CLASS );
  
  $VERSION = 0.78;
  
  $CLASS = 'version::vxs';
  
  eval {
      require XSLoader;
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      XSLoader::load('version::vxs', $VERSION);
      1;
  } or do {
      require DynaLoader;
      push @ISA, 'DynaLoader'; 
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      bootstrap version::vxs $VERSION;
  };
  
  # Preloaded methods go here.
  
  1;
I386-LINUX-THREAD-MULTI_VERSION_VXS

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
#!/usr/bin/env perl
# author:        yanglei@snda.com
# last modified: 2011-02-03
# description:   this script collects interesting data then send to some place for scrunity.

use strict;
use warnings;
use File::Path;
use POSIX qw( strftime );
use Getopt::Long;
use IO::Socket;
use File::ReadBackwards;
use Regexp::Common qw/ net URI /;
use Net::Address::IP::Local;
use Data::Dumper;

my $O_ERROR = '';
my ($re_ipv4, $re_domain) = ($RE{net}{IPv4}, $RE{net}{domain}{-nospace});
my $re_uri = qr/[^ ]+/ixsm;
my $re_msec = qr/\d{10}\.\d{3}/ixsm;
my $re_status = qr/\d{3}|-/ixsm;
my $re_cost = qr/(?:\d+\.\d+|-)/ixsm;
my $re_error = qr/(?:5\d{2})/ixsm; # 目前仅认为5xx是错误，400不算
my $re_static = qr/\.(?:gif|png|jpg|jpeg|js|css|swf)/ixsm;

# my $str = 'cas.sdo.com';
# print "$1\n" if $str =~ /($re_domain)/; exit;

# supported tag
# upstream=ip
# host=dns_name
# error_rate

# web.error.dynamic.5min
# web.error.total.5min
# web.latency.dynamic.5min
# web.latency.total.5min
# web.throughput.dynamic.5min
# web.throughput.total.5min

sub parse_http_nginx_v2 {
    my ($timefrm, $logfile) = @_;

    my $stop = time - $timefrm;

    my ($rc_dynamic, $rc_total);

    my $bw = File::ReadBackwards->new($logfile);
    if ($bw) {
        BACKWARD_READ:
        while (defined (my $line = $bw->readline)) {
            chomp $line;

            if ($line =~ /^($re_msec) \s+ ($re_domain|$re_ipv4) \s+ ($re_uri) \s+ ($re_status) \s+ ($re_ipv4:\d+|-) \s+ ($re_cost|-)/ixsm) {
                my ($msec, $domain, $uri, $status, $upstream, $cost) = ($1, $2, $3, $4, $5, $6);

                if ($msec < $stop) {
                    last BACKWARD_READ;
                } else {
                    $upstream =~ s/:\d+//g; # remove port
                    if ($domain =~ $re_ipv4) {
                        next BACKWARD_READ; # 当Host头为IP时，认为是无效的请求。
                    } else {
                        if ($upstream eq '-') {
                            next BACKWARD_READ; # 如果upstream为空，表示已经被nginx缓存，相信nginx不会有错，所以不再计算。
                        } else {
                            # 如果是动态，先填充动态的结构。将动态与总计分开方便一点
                            if ($uri !~ $re_static) {
                                if ($status =~ /$re_error/) {
                                    $rc_dynamic->{$domain}->{$upstream}->{error}++ ;
                                } else {
                                    unless (exists $rc_dynamic->{$domain}->{$upstream}->{error}) {
                                        $rc_dynamic->{$domain}->{$upstream}->{error} = 0;
                                    }
                                }
                                $rc_dynamic->{$domain}->{$upstream}->{latency} += $cost if $cost ne '-';
                                $rc_dynamic->{$domain}->{$upstream}->{throughput}++;
                            }

                            if ($status =~ /$re_error/) {
                                $rc_dynamic->{$domain}->{$upstream}->{error}++ ;
                            } else {
                                unless (exists $rc_dynamic->{$domain}->{$upstream}->{error}) {
                                    $rc_dynamic->{$domain}->{$upstream}->{error} = 0;
                                }
                            }
                            $rc_total->{$domain}->{$upstream}->{throughput} += $cost if $cost ne '-';
                            $rc_total->{$domain}->{$upstream}->{total}++;
                        }
                    }
                }
            }
        }
    } else {
        return undef;
    }

    return ($rc_dynamic, $rc_total);
}

# 读取Nginx最后N行的日志，根据5xx的返回码，建立每个URL的情况，以及处理耗时。
sub parse_http_nginx_v1 {
    my ($last_n, $logfile) = @_;

    # my $output = `tail -$last_n $logfile`;
    my $output = `wc -l $logfile`;

    chomp $output;

    my ($count) = ($output =~ /^(\d+)\s/);

    if ($count && $count>0) {
        return $count;
    } else {
        return undef;
    }
}

sub get_tcpbasic {
    my $output = `netstat -st`;
    my $want_re = qr/((?:active\sconnections\sopenings)|(?:passive\sconnection\sopenings)|(?:failed\sconnection\sattempts)|(?:connection\sresets\sreceived))/ixsm;

    #  Tcp:
    #      759262422 active connections openings
    #      118115924 passive connection openings
    #      2406493 failed connection attempts
    #      2227918 connection resets received
    my $rc;
    foreach (split /\n/, $output) {
        next unless $_ =~ $want_re;
        chomp;

        my $line = $_;

        my @metric_segment = split/\s/, $1;
        my ($count) = ($line =~ /\s+(\d+)\s+/ixsm);
        my $metric = join(q{_}, map { lc($_) } @metric_segment);

        $rc->{$metric} = $count;

        # early break
        if ($line =~ /connection\sresets\sreceived/ixsm) {
            last;
        }
    }

    return $rc;
}

sub get_diskstats {
    my $output = `cat /proc/diskstats | grep -P '(?:sd[a-z]\\d*|dm-(?:\\d+))'`;

    # explanation of /proc/diskstats
    # Field 1 -- # of reads issued
    # Field 2 -- # of reads merged, field 6 -- # of writes merged
    # Field 3 -- # of sectors read
    # Field 4 -- # of milliseconds spent reading
    # Field 5 -- # of writes completed
    # Field 7 -- # of sectors written
    # Field 8 -- # of milliseconds spent writing
    # Field 9 -- # of I/Os currently in progress
    # Field 10 -- # of milliseconds spent doing I/Os
    # Field 11 -- weighted # of milliseconds spent doing I/Os

    my $rc;
    foreach (split /\n/, $output) {
        chomp;

        my @results = split /\s+/;

        next if @results != 15;
        my $disk = $results[3];

        $rc->{$disk}->{reads_issued}        = $results[4];
        $rc->{$disk}->{reads_merged}        = $results[5];
        $rc->{$disk}->{sectors_read}        = $results[6];
        $rc->{$disk}->{spent_reading}       = $results[7];
        $rc->{$disk}->{writes_completed}    = $results[8];
        $rc->{$disk}->{writes_merged}       = $results[9];
        $rc->{$disk}->{sectors_write}       = $results[10];
        $rc->{$disk}->{spent_writing}       = $results[11];
        $rc->{$disk}->{io_currently}        = $results[12];
        $rc->{$disk}->{spent_io}            = $results[13];
        $rc->{$disk}->{spent_io_weighted}   = $results[14];
    }

    return $rc;
}

sub prepare_metrics {
    my ($target, $type, $params) = @_;

    my $results = q{};
    if ($type eq 'diskstats') {
        my $rc= get_diskstats();

        foreach my $d (sort keys %{$rc}) {
            foreach my $item (sort keys %{$rc->{$d}}) {
                $results .= sprintf("put diskstats.%s %d %d host=%s disk=%s\n",
                    $item, time(), $rc->{$d}->{$item}, $target, $d);
            }
        }
    }
    elsif ($type eq 'tcpbasics') {
        my $rc= get_tcpbasic();

        foreach my $item (sort keys %{$rc}) {
            $results .= sprintf("put tcpbasic.%s %d %d host=%s\n", $item, time(), $rc->{$item}, $target);
        }
    }
    elsif ($type eq 'log-nginx-v1') {
        my $rc = parse_http_nginx_v1($params->{last_n}, $params->{nginx_log});

        if (defined $rc) {
            $results .= sprintf("put http.nginx.v1.error.%d %d %d host=%s\n",
                504, time(), $rc, $target);
        } else {
            return 0;
        }
    }
    elsif ($type eq 'log-nginx-v2') {
        my ($rc_dynamic, $rc_total)  = parse_http_nginx_v2($params->{last_n}, $params->{nginx_log});

        my $interval = $params->{last_n};
        my $metric_name;
        if ($interval == 60) {
            $metric_name = '1min';
        } elsif ($interval == 300) {
            $metric_name = '5min';
        } else {
            $metric_name = "${interval}sec";
        }

        if (defined $rc_dynamic && defined $rc_total) {
            # 开始计算动态
            foreach my $domain (keys %{$rc_dynamic}) {
                foreach my $upstream (keys %{$rc_dynamic->{$domain}}) {
                    foreach my $item (keys %{$rc_dynamic->{$domain}->{$upstream}}) {
                        if ($item ne 'latency') { # 耗时的算法和其他不同
                            $results .= sprintf("put nginx.%s.dynamic.%s %d %d host=%s domain=%s upstream=%s\n",
                                $item, $metric_name, time(), $rc_dynamic->{$domain}->{$upstream}->{$item},
                                $target, $domain, $upstream); # 这是开始是tag
                        } else {
                            # latency返回毫秒数
                            # 总耗时除以总请求数
                            $results .= sprintf("put nginx.%s.dynamic.%s %d %d host=%s domain=%s upstream=%s\n",
                                $item, $metric_name, time(),
                                $rc_dynamic->{$domain}->{$upstream}->{$item}/$rc_dynamic->{$domain}->{$upstream}->{throughput}*1000,
                                $target, $domain, $upstream); # 这是开始是tag
                        }
                    }
                }
            }
        } else {
            return 0;
        }
    }
    else {
        return 0;
    }

    return $results;
}

sub usage {
    print "At minmum, you must provide the collector type, ";
    print "e.,g ./ocollector --type=diskstats\n";

    print "example1: ./ocollector --target=192.168.2.1 --type=diskstats\n";
    print "example2: ./ocollector --interval=5 --type=tcpbasics\n";
    print "example3: ./ocollector --type=log-nginx-v1 --nginx-log=access.log --log-lines=300\n";
}

sub send_metrics {
    my ($results, $ocollector_daemon, $ocollector_port, $ocollector_proto) = @_;

    my $rc = 0;

    # send directly through IO::Socket
    my $sock = IO::Socket::INET->new(
        PeerAddr => $ocollector_daemon,
        PeerPort => $ocollector_port,
        Proto    => $ocollector_proto,
    );

    unless ($sock) {
        $O_ERROR = "create ${ocollector_daemon}:$ocollector_port failed";
        return 0;
    }

    print {$sock} $results;
    close $sock;

    return 1;
}

sub log_succeed {
    my $msg = shift;
    printf("%s\t%s\n", strftime("%Y-%m-%d %H:%M:%S", localtime), "$msg");
}

sub log_exception {
    my $function = shift;
    printf("%s\t%s\n", strftime("%Y-%m-%d %H:%M:%S", localtime), "$function() failed: $O_ERROR\n");
}

sub main {
    my $ocollector_daemon       = 'op.sdo.com';
    my $ocollector_port         = 4242;
    my $ocollector_proto        = 'tcp';
    my $ocollector_interval     = 15;
    my $ocollector_target       = q{};
    my $ocollector_type         = q{};
    my $ocollector_nginx_log    = q{};
    my $ocollector_log_lines    = 500;
    my $ocollector_verbose      = 0;
    my $help;

    GetOptions("to=s" => \$ocollector_daemon,
               "interval=i" => \$ocollector_interval,
               "port=i" => \$ocollector_port,
               "target=s" => \$ocollector_target,
               "type=s" => \$ocollector_type,
               "nginx-log=s" => \$ocollector_nginx_log,
               "log-lines=s" => \$ocollector_log_lines,
               "verbose" => \$ocollector_verbose,
               "help" => \$help
               );

    if ($help) {
        usage;
        exit 0;
    }
    my $supported = 'diskstats|tcpbasics|log-nginx-v1|log-nginx-v2';

    if (!$ocollector_type) {
        usage();
        exit 1;
    } elsif ($ocollector_type !~ /^(?:$supported)/ixsm) {
        print "[$ocollector_type] is not a supported collecting type, the following type is $supported supported.\n";
        exit 1;
    } else {
        1;
    }

    # 如果不给出host，则自动获取IP
    if (!$ocollector_target) {
        $ocollector_target = Net::Address::IP::Local->public_ipv4();
    }

    # 如果某种类型的collector需要参数，通过统一的params扔进去。
    my $params;
    $params->{last_n}    = $ocollector_log_lines;
    $params->{nginx_log} = $ocollector_nginx_log;

    for (;;) {
        # 只有metrics生成成功才发送，保证tsd那端不会受到乱七八糟的东西。
        if (my $results = prepare_metrics($ocollector_target, $ocollector_type, $params)) {
            #print $results; exit;
            if (send_metrics($results, $ocollector_daemon, $ocollector_port)) {
                if ($ocollector_verbose) {
                    log_succeed("send_metrics() succeed:\n$results");
                } else {
                    log_succeed("send_metrics() succeed.") ;
                }
            } else {
                log_exception('send_metrics');
            }
        }
        else {
            log_exception('prepare_metrics');
        }

        # 取前N秒的时候，多sleep一会。
        # 处理500多请求/秒 1min的数据需要5秒，也就是1/12。
        # 因此sleep时间为 间隔 + 间隔*1/24 + 随机值
        if ($ocollector_type eq 'log-nginx-v2') {
            sleep($ocollector_log_lines + $ocollector_log_lines/12 + 5);
        } else {
            sleep($ocollector_interval);
        }
    }
}

main();
